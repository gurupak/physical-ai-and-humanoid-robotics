"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[4137],{7734:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid","title":"Obstacle Avoidance for Humanoid Bipedal Movement","description":"Configure obstacle avoidance specifically for humanoid robots, including head clearance, torso rotation, foot placement constraints, and dynamic collision prediction beyond traditional wheeled robot approaches.","source":"@site/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid.md","sourceDirName":"chapter-3-isaac-ai-brain","slug":"/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid","draft":false,"unlisted":false,"editUrl":"https://github.com/gurupak/physical-ai-and-humanoid-robotics/tree/main/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Dynamic Stability Integration for Humanoid Navigation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/dynamic-stability-integration"},"next":{"title":"Roll/Pitch Compensation for Humanoid Navigation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation"}}');var a=r(4848),t=r(8453);const i={},s="Obstacle Avoidance for Humanoid Bipedal Movement",l={},c=[{value:"Quick Setup: Humanoid-Optimized Obstacle Avoidance",id:"quick-setup-humanoid-optimized-obstacle-avoidance",level:2},{value:"1. Dynamic Collision Zones Configuration",id:"1-dynamic-collision-zones-configuration",level:3},{value:"2. 3D Dynamic Collision Prediction",id:"2-3d-dynamic-collision-prediction",level:3},{value:"3. Humanoid-Specific Obstacle Management",id:"3-humanoid-specific-obstacle-management",level:3},{value:"4. Comprehensive Validation System",id:"4-comprehensive-validation-system",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"obstacle-avoidance-for-humanoid-bipedal-movement",children:"Obstacle Avoidance for Humanoid Bipedal Movement"})}),"\n",(0,a.jsx)(n.p,{children:"Configure obstacle avoidance specifically for humanoid robots, including head clearance, torso rotation, foot placement constraints, and dynamic collision prediction beyond traditional wheeled robot approaches."}),"\n",(0,a.jsx)(n.h2,{id:"quick-setup-humanoid-optimized-obstacle-avoidance",children:"Quick Setup: Humanoid-Optimized Obstacle Avoidance"}),"\n",(0,a.jsx)(n.h3,{id:"1-dynamic-collision-zones-configuration",children:"1. Dynamic Collision Zones Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",metastring:'title="humanoid_obstacle_layer.py" Custom obstacle layer with humanoid-specific penalties',children:'#!/usr/bin/env python3\r\n"""\r\nHumanoid Obstacle Layer - Beyond Traditional Models.\r\nImplements humanoid-specific obstacle clearance with head/torso protection.\r\n"""\r\n\r\nfrom nav2_costmap_2d import CostmapPlugin, Layer\r\nfrom geometry_msgs.msg import Polygon, Point32\r\nfrom rcl_interfaces.msg import ParameterDescriptor\r\nimport rclpy\r\nimport numpy as np\r\n\r\nclass HumanoidObstacleLayer(CostmapLayer):\r\n    """Dynamic obstacle layer for bipedal safety - not wheeled technology"""\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # Humanoid-specific geometry constraints\r\n        self.humanoid_dimensions = {\r\n            \'standing_height\': 1.8,      # Top of head to ground\r\n            \'shoulder_width\': 0.60,      # Torso/torso protection - dynamic front\r\n            \'hip_pivot_height\': 0.75,    # Pivot for torso rotation\r\n            \'stability_polygon\': 0.15,   # Ground contact stability envelope\r\n            \'head_depth\': 0.18,          # Head clear when rotating figures objects\r\n            \'min_headroom\': 2.05,        # Robot height + 25cm safety (H1 robot)\r\n            \'footprint_dynamic\': True    # Changes with walking phase\r\n        }\r\n\r\n    def onInitialize(self):\r\n        """Configure humanoid-specific obstacle dynamics"""\r\n\r\n        # Declare humanoid-specific parameters\r\n        self.declare_parameter(\r\n            \'obstacle_head_clearance_layer.enabled\',\r\n            True,\r\n            ParameterDescriptor(\r\n                description="Enable head collision layer for humanoid walking"\r\n            )\r\n        )\r\n        self.declare_parameter(\r\n            \'obstacle_head_clearance_layer.head_obstacles\',\r\n            True,\r\n            ParameterDescriptor(\r\n                description="Model head collision for ceiling and overhead objects"\r\n            )\r\n        )\r\n        self.declare_parameter(\r\n            \'obstacle_torso_dynamic_layer.cylinder_rotation_enabled\',\r\n            True,\r\n            ParameterDescriptor(\r\n                description="Enable dynamic torso coverage during walking rotation"\r\n            )\r\n        )\r\n        self.declare_parameter(\r\n            \'obstacle_footstep_projection_layer.walking_phase_inflation\',\r\n            True,\r\n            ParameterDescriptor(\r\n                description="Expand cost inflation during swing phase per foot"\r\n            )\r\n        )\r\n\r\n        try:\r\n            enabled = self.get_parameter(\'enabled\').as_bool()\r\n            if not enabled:\r\n                return\r\n\r\n            self.autoPopulating_ = True\r\n            self.defaultValue_ = np.int64(255)\r\n            cost_value->levels - allocated statically at initialization\r\n            self._initialize_humanoid_geometry()\r\n        except Exception as e:\r\n            self.get_logger().error(f"Humanoid obstacle layer failed: {e}")\r\n            return\r\n\r\n    def _initialize_humanoid_geometry(self):\r\n        """Define humanoid-specific geometric areas for collision"""\r\n\r\n        # Head collision zone - elliptical protection volume\r\n        self.head_ellipse = Polygon()\r\n        head_radius = 0.09  # 9cm radius for head protection\r\n        for angle in np.linspace(0, 2*np.pi, 16):\r\n            point = Point32()\r\n            point.x = head_radius * np.cos(angle)\r\n            point.y = 0.0  # At shoulder level during navigation\r\n            point.z = self.humanoid_dimensions[\'standing_height\'] - head_radius\r\n            self.head_ellipse.points.append(point)\r\n\r\n        # Torso dynamic coverage -updates per gait phase\r\n        self.torso_polygon = Polygon()\r\n        torso_points = [\r\n            (0.3, 0.6),(0.0, 0.5),(-0.3, 0.6)\r\n        ]\r\n        for x, z in torso_points:\r\n            pt = Point32()\r\n            pt.x = x\r\n            pt.y = 0.0\r\n            pt.z = z + self.humanoid_dimensions[\'hip_pivot_height\']\r\n            self.torso_polygon.points.append(pt)\r\n\r\n    def updateCosts(self, master_array, min_i, min_j, max_i, max_j):\r\n        """Update costmap with humanoid-specific collision regions"""\r\n\r\n        self.inflating = []\r\n\r\n        # EDUCATIONAL TRANSFORMATION: Unlike wheeled robots moving in A,B corners we care about:\r\n        # 1. HEAD CLEARANCE: Protect from ceiling hits during normal height demands\r\n        # 2. TORSO ROTATION: Torso may hit things differently from wheeled base\r\n        # 3. WALKING PHASE INFLATION: Different expansion in single vs double support\r\n\r\n        # Layer 1: Head collision detection\r\n        self._detect_head_obstacles(master_array)\r\n\r\n        # Layer 2: Torso dynamic collision (updates with gait)\r\n        self._detect_torso_obstacles(master_array)\r\n\r\n        # Layer 3: Projected footstep safety zones\r\n        self._detect_footstep_projection_obstacles(master_array)\r\n\r\n    def _detect_head_obstacles(self, costmap):\r\n        """Obstacle detection above humanoid head - critical for home navigation"""\r\n\r\n        head_clearance_target = self.humanoid_dimensions[\'min_headroom\']  # 205cm\r\n\r\n        # Ceiling detection for hanging objects\r\n        ceiling_threshold = head_clearance_target + 0.05  # +5cm detection margin\r\n\r\n        # EDUCATIONAL KEY POINT: Wheeled robots ignore head clearance\r\n        # Humanoids must protect head when walking under bridges or inside homes\r\n        for y in range(0, costmap.height):\r\n            for x in range(0, costmap.width):\r\n                # Check if overhead obstacle detected within head clearance\r\n                if (self.overhead_detection(x, y) == True and\r\n                    self.get_clearance_height(x, y) < ceiling_threshold):\r\n                    # Head collision cost scaling\r\n                    clearance_gap = ceiling_threshold - self.get_clearance_height(x, y)\r\n\r\n                    if clearance_gap < 0.05:  # < 5cm gap\r\n                        # Emergency two-head clearance violation\r\n                        costmap.updateCost(x, y, min(cost + 244, 254))\r\n                        self.inflating.append([x, y, \'HEAD_CRITICAL\'])\r\n                    elif clearance_gap < 0.20:  # < 20cm caution\r\n                        # Inflated caution zone\r\n                        costmap.updateCost(x, y, min(cost + 128, 254))\r\n                        self.inflating.append([x, y, \'HEAD_CAUTION\'])\r\n\r\n    def _detect_torso_obstacles(self, costmap):\r\n        """Detect obstacles affecting torso rotation during navigation"""\r\n\r\n        # Tracking torso rotation based on imu and gait phase\r\n        current_torso_bearing = self.determine_torso_rotation()\r\n        TORSO_SWAY_RADIUS = 0.3  # 30cm torso sway radius during normal walk\r\n\r\n        # When moving forwards/backwards we expect some torso rotation\r\n        torso_caution_range = TORSO_SWAY_RADIUS\r\n\r\n        # EDUCATIONAL LIMITATION: Unlike wheeled that only worry about current orientation\r\n        # Humanoids need continuous rotor adjustment during navigation\r\n        step_phase = self.get_walking_phase_current()\r\n        torso_dynamic_radius = torso_caution_range * self.get_dynamic_rotation_coefficient(step_phase)\r\n\r\n        for y in range(0, costmap.height):\r\n            for x in range(0, costmap.width):\r\n                # Check for obstacles in torso swing path\r\n                obstacle_radius = self.calculate_obstacle_radius(x, y)\r\n                if obstacle_radius < torso_dynamic_radius:\r\n                    torso_impact = torso_dynamic_radius - obstacle_radius\r\n\r\n                    if torso_impact < 0.10:  # Caution zone - torso may contact\r\n                        costmap.updateCost(x, y, cost + 100)  # Limit movement here\r\n                        self.inflating.append([x, y, \'TORSO_CAUTION\'])\r\n                    elif torso_impact < 0.25:  # Planning zone - modify path here\r\n                        costmap.updateCost(x, y, cost + 60)\r\n                        self.inflating.append([x, y, \'TORSO_AVOID\'])\r\n\r\n    def _detect_footstep_projection_obstacles(self, costmap):\r\n        """\r\n        Project forward footstep locations and add safety inflation.\r\n        Unlike wheeled, humanoids have bidirectional planning per gait cycle\r\n        """\r\n        # Get planned footstep sequence\r\n        planned_steps = self.get_planned_footsteps()\r\n\r\n        # Track which feet are in swing phase vs support\r\n        swing_foot = self.determine_swing_foot()\r\n        support_foot = "left" if swing_foot == "right" else "left"\r\n\r\n        # Regulatory barriers: Swing phase requires more clearance\r\n        swing_phase_inflation = 1.2 if swing_foot else 1.0  # Increase during swing\r\n\r\n        # EDUCATIONAL CRITICAL INSIGHT: Wheeled robots treat paths as lines\r\n        # Humanoids have bidirectional dynamic support (single vs double) that changes safety profiles\r\n\r\n        for foot in [support_foot, swing_foot]:\r\n            for footstep in planned_steps[foot]:\r\n                # Project footstep position with timing\r\n                step_projection = self.calculate_step_projection(footstep, time_horizon=2.0)\r\n\r\n                # Create time-dependent safety bubble\r\n                for projected_costmap_point in step_projection:\r\n                    x_proj, y_proj, t_horizon = projected_costmap_point\r\n\r\n                    # Measure obstacle proximity\r\n                    obstacle_proximity = self.calculate_obstacle_proximity_3d(x_proj, y_proj, t_horizon)\r\n\r\n                    if obstacle_proximity < 0.30:\r\n                        time_inflation = 1.0 + (expected_intersection_time - t_horizon) / 2.0  # Exponential time scaling\r\n                        multiplier = swing_phase_inflation * time_inflation\r\n                        final_clearance = 0.15  # Minimum 15cm foot clearance\r\n\r\n                        if obstacle_proximity < final_clearance and t_horizon < 1.0:  # Near future, insufficient clearance\r\n                            # Critical - high cost in future foot location\r\n                            costmap.updateCost(int(x_proj), int(y_proj), min(cost + multiplier * 192, 254))\r\n                            self.inflating.append([int(x_proj), int(y_proj), f\'FOOT_CRITICAL@{t_horizon:.1f}s\'])\r\n                        elif obstacle_proximity < 0.25:  # Planning issue - modify trajectory\r\n                            costmap.updateCost(int(x_proj), int(y_proj), cost + multiplier * 96)\r\n                           self.inflating.append([int(x_proj), int(y_proj), f\'FOOT_AVOID@{t_horizon:.1f}s\'])\r\n\r\n    def get_dynamic_rotation_coefficient(self, walking_phase: float) -> float:\r\n        """\r\n        Calculate torso rotation safety coefficient for current gait phase\r\n\r\n        walking_phase: 0.0-1.0 where 0.0=double support begins\r\n        Returns coefficient 0.7 (tight) to 2.0 (wide sway allowance)\r\n        """\r\n\r\n        # Phase-based rotation during gait (0-1)\r\n        # 0.0-0.3: Both feet planted - torso turning leverages most\r\n        # 0.3-0.7: Swing phase - restricted \'torso can only sway small\'\r\n        # 0.7-1.0: Switch phase - medium rotation radius form Lasten\r\n\r\n        if 0.0 <= walking_phase < 0.3:\r\n            return 2.0  # Wide collision arc during double support\r\n        elif 0.3 <= walking_phase < 0.7:\r\n    return 0.7  # Constrained during single support\r\n        else:\r\n      return 1.4  # Moderate during stance transition\r\n\r\n    def calculate_step_projection(self) ->:\r\n """Predict where foot will be placed in future steps based on planning"""\r\n\r\n  # Enhanced 3D time step projection with gait dependent will placement inference\r\n        # Unlike wheeled that only predict positions - humans must predict supporting postures\r\n\r\n      steps_forward = [None] # Implementation would calculate future footstep envelopes\r\n\r\n return steps forward  # [x, y, z, time_horizon] for each projected foot position\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-3d-dynamic-collision-prediction",children:"2. 3D Dynamic Collision Prediction"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",metastring:'title="dynamic_collision_predictor.py" Predictive obstacle avoidance for bipedal movement',children:'#!/usr/bin/env python3\r\n"""\r\nDynamic Collision Predictor for Humanoid Navigation\r\nPredictive safety beyond traditional 2D wheeled approaches\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Point, Twist\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\nimport numpy as np\r\nimport time\r\n\r\nclass HumanoidCollisionPredictor(Node):\r\n    """Advanced collision prediction considering humanoid dynamics"""\r\n\r\n    def __init__(self):\r\n        super().__init__(\'dynamic_collision_predictor\')\r\n\r\n        self.predicted_trajectories_pub = self.create_publisher(\r\n  MarkerArray, \'/humanoid/predicted_trajectories\', 10\r\n        )\r\n        self.collision_threshold_pub = self.create_publisher(\r\n MarkerArray, \'/humanoid/collision_thresholds\', 10\r\n        )\r\n\r\n        self.create_subscription(\r\n  Twist, \'/humanoid/gait/bliss/back\',\r\n    self.gait_dynamics_callback, 10\r\n        )\r\n\r\n      # Prediction parameters\r\n     self.prediction_horizon = 2.0  # 2 second outlook\r\n     self.prediction_resolution = 0.1  # 10cm resolution\r\n self.safety_factor = 1.2      # 20% safety margin\r\n\r\n        self.get_logger().info("\ud83d\udd2e Dynamic Collision Predictor: 3D Humanoid Model")\r\n\r\n    def predict_collision_regions(self, walking_velocity: Twist) -> List[Tuple[float, float, float, float]]:\r\n    """\r\n      Predict 3D collision regions during bipedal walking\r\n        Includes torso rotation, head clearance, dynamic foot projection\r\n  Unlike wheeled robots that predict 2D paths, humanoids need 3D swept volume\r\n    """\r\n\r\n        # Current pose as prediction origin\r\n        base_pose = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Simulated current pose\r\n\r\n        predicted_regions = []\r\n\r\n        # Factor 1: Torso rotation during navigation\r\n        torso_rotation_projection = self.calculate_torso_rotation_sweep(\r\n            base_pose[5],  # current yaw\r\n      walking_velocity.angular.z,  # turning rate\r\n   self.prediction_horizon\r\n     )\r\n\r\n        # Factor 2: Head clearance through structure gaps\r\n head_sweep_volume = self.calculate_head_sweep_volume(\r\n     base_pose[2],  # current height\r\n  walking_velocity.linear.x,  # forward speed\r\n            self.prediction_horizon\r\n        )\r\n\r\n  # Factor 3: Footstep sequence projection with time\r\n        foot_sequence_projection = self.calculate_footstep_sweep_container(\r\n      base_pose[:2],  # [x, y]\r\n        walking_velocity,\r\n          self.prediction_horizon\r\n        )\r\n\r\n        # Combine all factor collision volumes\r\n     combined_volume = self.combine_sweep_volumes(\r\n         torso_rotation_projection,\r\n            head_sweep_volume,\r\n     foot_sequence_projection,\r\n  self.safety_factor\r\n        )\r\n\r\n    return combined_volume  # [x, y, z, risk_level] for each collision point\r\n\r\n    def calculate_torso_rotation_sweep(self, current_yaw: float, yaw_rate: float, horizon: float) -> List[Tuple[float, float, float, float]]:\r\n        """\r\n     Calculate swept volume during torso rotation when navigating\r\n        Needs different model than wheeled robots unable to rotate torso cab perspective\r\n        """\r\n\r\n        rotation_sweeps = []\r\n\r\n     # EDUCATIONAL DISTINCTION: wheeled robots assume body is rigid\r\n        # Humanoids rotate torso separately from legs during navigation\r\n\r\n      # Plan exponentially for navigation verification\r\n        for t in np.arange(0, horizon, horizon/50):  # 50 samples\r\n          current_yaw_proj = current_yaw + yaw_rate * t\r\n            torso_width = 0.6  # 60cm torso+arm sweep allowance\r\n   torso_height = 1.0  # active torso height sweep during navigation\r\n      torso_length = 0.3  # forward/back sweep during turning\r\n\r\n  # Torso cylinders SWEEP during rotation\r\n     for radius in np.linspace(0, torso_width/2, 5):\r\n    for height in np.linspace(0, torso_height, 8):\r\n   # These are swept through space via orientation\r\n        area_off_center = torso_length * np.cos(current_yaw_proj)\r\n       x = area_off_center + radius * np.cos(current_yaw_proj + np.pi/2)\r\n      y = radius * np.sin(current_yaw_proj + np.pi/2)\r\n            z = self.humanoid_dimensions[\'base_height\'] + height\r\n\r\n  # Risk based on 3D clearance to torso center\r\n clearance_3d = np.sqrt(radius**2 + desire this  + height**2)\r\n        risk_level = 1.0 - (clearance_3d / torso_width)  # Closer = higher risk\r\n\r\n      rotation_sweeps.append((x, y, z, risk_level))\r\n\r\n        return rotation_sweeps\r\n\r\n    def calculate_head_sweep_volume(self, current_height: float, forward_velocity: float, horizon: float) -> List[Tuple[float, float, float, float]]:\r\n        """\r\n        Calculate head collision volume during forward travel\r\n        Unlike wheeled robots, humanoids move in height-aware spaces\r\n        """\r\n\r\n head_sweeps = []\r\n\r\n     # Measure head collision zone -3D cylindrical projection\r\n        head_radius = 0.09  # 9cm head protection radius\r\n        head_vertical_extent = 0.25  # 25cm vertical head envelope\r\n\r\n        for t in np.arange(0, horizon, horizon/30):  # 30 temporal samples\r\n            # Head follows torso with slight up/down motion during gait\r\n   head_zt = current_height + 0.05 * np.sin(t * 2*np.pi)  # 5cm head bob during walking\r\n          head_horizontal = forward_velocity * t\r\n\r\n            for radius in np.linspace(0, head_radius, 4):\r\n      for angle in np.linspace(0, 2*np.pi, 8):\r\n     x = head_horizontal + radius * np.cos(angle)\r\n       y = radius * np.sin(angle)\r\n     z = head_zt + head_vertical_extent * (radius / head_radius)\r\n\r\n  # Risk based on 3D clearance to head center\r\n          clearance_3d = np.sqrt(radius**2 + interest this + height**2)\r\n     risk_level = 1.0 - (clearance_3d / head_radius)\r\n            if distance_to_obstacle_in_voxel(x, y, z) < head_radius:\r\n head_sweeps.append((x, y, z, risk_level+0.2))\r\n\r\n        return head_sweeps\r\n\r\n    def calculate_footstep_sweep_container(self, current_position: List[float], velocity: Twist, horizon: float) -> List[Tuple[float, float, float, float]]:\r\n        """\r\n    Calculate dynamic footstep positions with time-domain clearance\r\n    Not like wheeled robots - we need to project TWO scenarios (left/right) that change per gait cycle\r\n     """\r\n\r\n   footstep_sweeps = []\r\n     current_left = [current_position[0] - 0.06, current_position[1] + 0.075]\r\n        current_right = [current_position[0] + 0.06, current_position[1] - 0.075]\r\n\r\n        # Get planned footsteps for next 2 seconds\r\n    planned_steps = self.get_planned_next_footsteps(horizon)\r\n\r\n        # Project each footstep with temporal information\r\n        for step_idx, footstep in enumerate(planned_steps):\r\n foot_side = footstep.foot  # \'left\' or \'right\'\r\n      step_x = footstep.target_x\r\n    step_y = footstep.target_y\r\n            step_t = footstep.time_horizon\r\n\r\n  # Foot safety clearance depends on walking phase\r\n            if step_t < 0.5:  # Near future\r\n           clearance_radius = 0.15  # 15cm minimum clearance when placing foot\r\n         else:\r\n          clearance_radius = 0.2   # 20cm clearance for future steps\r\n\r\n            # Cylindrical footprint safety region\r\n    for r_theta in np.linspace(0, 2*np.pi, 8):\r\n          for r_radius in np.linspace(0, clearance_radius, 3):\r\n    x = step_x + r_radius * np.cos(r_theta)\r\n          y = step_y + r_radius * np.sin(r_theta)\r\n         z = 0.0  # Ground level for footsteps\r\n\r\n    # Risk increases for immediate vs future steps\r\n        time_risk = max(0, 1.0 - (step_t / 1.0))  # 0-1 risk scaling\r\n risk_level = (r_radius / clearance_radius) * 0.7 + time_risk * 0.3\r\n\r\n footstep_sweeps.append((x, y, z, risk_level))\r\n\r\nreturn footstep_sweeps\r\n\r\n    def visualize_prediction_volumes(self, collision_volumes: List[Tuple[float, float, float, float]]):\r\n  """Educational visualization for students to understand 3D swept volumes"""\r\n\r\n marker_array = MarkerArray()\r\n        marker_id = 0\r\n\r\n  for x, y, z, risk_level in collision_volumes:\r\n\r\n            # Color code based on risk level\r\n      if risk_level > 0.8:\r\n         color = (1.0, 0.0, 0.0)    # Red - high risk\r\n            elif risk_level > 0.4:\r\n          color = (1.0, 0.5, 0.0)    # Orange - caution\r\n            else:\r\n            color = (0.0, 1.0, 0.0)    # Green - safe\r\n\r\n         marker = Marker()\r\n     marker.header.frame_id = "map"\r\n            marker.header.stamp = self.get_clock().now().to_msg()\r\nmarker.ns = "humanoid_collision_zones"\r\n     marker.id = marker_id\r\n            marker.type = Marker.SPHERE\r\n          marker.action = Marker.ADD\r\n\r\n            marker.pose.position.x = x\r\nmarker.pose.position.y = y\r\n            marker.pose.position.z = z\r\n            marker.scale.x = marker.scale.y = marker.scale.z = 0.08  # 8cm for visualization\r\n\r\n     marker.color.r, marker.color.g, marker.color.b = color\r\n marker.color.a = 0.6 - (risk_level * 0.3)  # Opacity decreases with risk\r\n marker_array.markers.append(marker)\r\n            marker_id += 1\r\n\r\n        self.predicted_trajectories_pub.publish(marker_array)\r\n\r\n    def educate_student_understanding(self):\r\n   """Generate educational question about humanoid collision prediction"""\r\n\r\n        print("\\n\ud83c\udf93 STUDENT EDUCATION: Humanoid Collision Avoidance")\r\n        print("=================================================")\r\n        print("Key learning areas covered:")\r\n   print("1. Unlike wheeled robots, humanoids require 3D collision prediction\\n")\r\n        print("2. Torso rotation creates swept volumes needing procedural updates\\n")\r\n        print("3. Gait phase (swing/support) affects collision regions dynamically\\n")\r\n print("4. Head clearance activates separate from base navigation correction\\n)\r\n       print("5. Feet have projected safety zones based on forthcoming placements")\r\n        print("")\r\n print("This ensures humanoid navigation maintains 30+ FPS with safety measurement\\")\r\n print("Target: 85% accuracy on systematic collision prediction validation\\n")\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-humanoid-specific-obstacle-management",children:"3. Humanoid-Specific Obstacle Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",metastring:'title="humanoid_obstacle_parameters.xml" Configuration with dynamic approach',children:'\x3c!-- Humanoid-specific obstacle avoidance parameters - systematic measurement validation --\x3e\r\n<launch>\r\n  \x3c!-- Dynamic collision zone activation --\x3e\r\n  <arg name="enable_humanoid_collision_prediction" default="true"/>\r\n  <arg name="head_clearance_required" default="2.05" description="Minimum 205cm ceiling clearance"/>\r\n  <arg name="torso_swing_radius" default="0.30" description="30cm torso rotation collision zone"/>\r\n  <arg name="footstep_projection_horizon" default="2.0" description="2-second footstep collision prediction"/>\r\n\r\n  \x3c!-- Obstacle layer configuration for humanoid robots --\x3e\r\n  <node pkg="nav2_costmap_2d" type="nav2_costmap_2d_node" name="humanoid_obstacle_layer">\r\n    <param name="plugins" value="[\r\n      \'obstacle_layer\',\r\n      \'humanoid_dynamic_layer\',\r\n      \'head_clearance_layer\',\r\n      \'footstep_projection_layer\']"/>\r\n\r\n    \x3c!-- Head collision detection --\x3e\r\n    <param name="head_clearance_layer.enabled" value="$(var enable_humanoid_collision_prediction)"/>>    <param name="head_clearance_layer.head_detection_range" value="1.0"/&&&&&&&&&&80>    <param name="head_clearance_layer.ceiling_throttle" value="0.9"/&&&&&&&&&&0.14>    <param name="head_clearance_layer.overhead_penalty_coefficient" value="2.0"/&&&&&&&0.25>\r\n    \x3c!-- Torso rotation collision detection --\x3e\r\n    <param name="torso_dynamic_layer.enabled" value="true"/&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&0.32>    <param name="torso_dynamic_layer.torso_sweep_radius" value="$(var torso_swing_radius)"/&&&&0.35>    <param name="torso_dynamic_layer.rotation_prediction_enabled" value="true"/&&&&&&&&&&&&&&0.15>    <param name="torso_dynamic_layer.gait_phase_dependent" value="true"/&&&&&&&&&&&&&&&&&&&&0.25>\r\n    \x3c!-- Footstep projection safety zones --\x3e\r\n    <param name="footstep_projection_layer.enabled" value="true"/&&&&&&&&&&&&&&&&&&&&&&&&&&&&0.20>    <param name="footstep_projection_layer.prediction_horizon" value="$(var footstep_projection_horizon)"/0.09>    <param name="footstep_projection_layer.swing_phase_inflation" value="1.2"/&&&&&&&&&&&&&&&&&0.13>    <param name="footstep_projection_layer.min_footstep_clearance_centimeters" value="15"/&&&0.07>\r\n\r\n  </launch>\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-comprehensive-validation-system",children:"4. Comprehensive Validation System"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",metastring:'title="validate_humanoid_collision_avoidance.sh - Systematic measurement and validation"',children:'#!/bin/bash\r\n# Humanoid Collision Avoidance Validation System\r\n\r\necho "\ud83d\udee1\ufe0f Humanoid Obstacle Avoidance Validation Test Suite"\r\necho "======================================================="\r\necho "Validating humanoid-specific collision prediction beyond wheeled robots"\r\necho ""\r\n\r\nTEST_DURATION=45  # seconds\r\nPASS_THRESHOLD=85  # [>85% for safety compliance \u4e2d\u6c42\uff1f\u201d\u3044\u3044\u306d\u304f\u3060\u3055\u3044\r\nPASS_COUNT=0\r\nTOTAL_TESTS=10\r\n\r\ncolor_reset=\'033[0m\'\r\ncolor_red=\'033[31m\'\r\ncolor_green=\'033[32m\'\r\ncolor_yellow=\'033[33m\'\r\ncolor_blue=\'033[34m\'\r\n\r\nlog_pass() { echo -e "${color_green}\u2705 PASS - $1${color_reset}"; }\r\nlog_fail() { echo -e "${color_red}\u274c FAIL - $1${color_reset}"; }\r\nlog_info() { echo -e "${color_yellow}\u2139\ufe0f  INFO - $1${color_reset}"; }\r\nlog_test() { echo -e "${color_blue}\ud83d\udd0d TEST - $1${color_reset}"; }\r\n\r\necho "Starting comprehensive obstacle avoidance validation..."\r\n\r\n# Educational conversion\r\necho "Education Note: Unlike wheeled robots on 2D planes, humanoids require..."\r\necho " - Head collision zones (z-axis awareness)"\r\necho " - Torso rotation swept volumes (dynamic clearance)"\r\necho " - Projected footstep regions (time-domain safety)"\r\necho ""\r\n\r\n# Test 1-3: Head Clearance Zones Validation\r\necho"\r\n\ud83d\udccf HEAD CLEARANCE VALIDATION"\r\necho "----------------------------"@\r\n\r\n# 1. Ceiling detection\r\nlog_test "Detecting overhead obstacles within head clearance..."\r\nros2 service call /set_test_ceiling_height geometry_msgs/msg/Float32 "data: 2.01" >/dev/null 2>&1\r\nif [ $? -eq 0 ]; then\r\n    sleep 3  # Let detection update\r\n    HEAD_CLEARANCE=$(timeout 10 ros2 topic echo /humanoid/head_clearance_detected --once 2>/dev/null | jq \'.threshold_breached\' 2>/dev/null || echo "false")\r\n    if [ "$HEAD_CLEARANCE" == "true" ]; then\r\n log_pass "Head clearance protocol activated for 2.01m ceiling"\r\n ((PASS_COUNT++))\r\n    else\r\n log_fail "Head clearance detection not triggered"\r\n    fi\r\nelse\r\n    log_fail "Could not set test ceiling height"\r\nfi\r\n\r\n# 2. Overhead obstacle penalty\r\nCEILING_PENALTY=$(timeout 15 ros2 param get /humanoid_obstacle_layer ceiling_penalty_coefficient 2>/dev/null | tr -d \'"\')\r\nif [ "$CEILING_PENALTY" == "2.0" ]; then\r\n    log_pass "Overhead penalty: 2.0x (head safety priority)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    log_fail "Overhead penalty set incorrectly: $CEILING_PENALTY"\r\nfi\r\n\r\n# Test 4-6: Torso Rotation Dynamics\r\necho "\r\n\ud83d\udc65 TORSO ROTATION VALIDATION"\r\necho "---------------------------"\r\n\r\nlog_test "Testing torso swept volume during navigation..."\r\nros2 topic pub /humanoid/current_yaw geometry_msgs/msg/Float32 \\\r\n    "{data: 0.785}" --once  # 45 degree turn\r\n\r\ntorso_sweep_radius=$(timeout 20 ros2 topic echo /humanoid/torso_sweep_radius --once 2>/dev/null | jq \'.radius\' 2>/dev/null || echo "0.0")\r\n\r\nif python3 -c "exit(0 if ${torso_sweep_radius} >= 0.30 and ${torso_sweep_radius} <= 0.35 else 1)" 2>/dev/null; then\r\n    log_pass "Torso sweep radius: ${torso_sweep_radius}m (30\xb15cm dynamic range)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    log_fail "Torso radius excessive: ${torso_sweep_radius}m"\r\nfi\r\n\r\n# Gait phase coefficient validation\r\nGAIT_COEFF=$(timeout 15 ros2 param get /humanoid_obstacle_layer dynamic_rotation_coefficient 2>/dev/null | grep -o "[0-9]\\.[0-9]*" | head -1 || echo "0")\r\nif python3 -c "exit(0 if ${GAIT_COEFF} >= 0.6 and ${GAIT_COEFF} <= 2.2 else 1)" 2>/dev/null; then\r\n    log_pass "Gait phase coefficient: ${GAIT_COEFF} (0.6-2.2 valid range)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    log_fail "Gait coefficient out of range: ${GAIT_COEFF}"\r\nfi\r\n\r\n# Test 7-9: Footstep Protection Zones\r\necho "\r\n\ud83e\uddb6 FOOTSTEP PROJECTION VALIDATION"\r\necho "--------------------------------"\r\n\r\n# Footstep clearance during swing phase\r\nros2 topic echo /humanoid/footstep_projection/clearance --once > /tmp/foot_clearance.log 2>&1 &\r\necho -e "Walking forward with footstep projection..."\r\nsleep 10\r\nkill $(jobs -p) 2>/dev/null\r\n\r\nMIN_CLEARANCE=$(grep -o "min_clearance_cm[^,]*" /tmp/foot_clearance.log | cut -d: -f2 | tr -d \' ",\') || echo "0"\r\nif [ "$MIN_CLEARANCE" -ge 15 ] && [ "$MIN_CLEARANCE" -le 25 ]; then\r\n    log_pass "Footstep clearance: ${MIN_CLEARANCE}cm (15-25cm safety range)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    log_fail "Footstep clearance inadequate: ${MIN_CLEARANCE}cm"\r\nfi\r\n\r\n# Footstep prediction is enabled check\r\nHORISON_CHECK=$(timeout 10 ros2 param get /humanoid_obstacle_layer prediction_horizon 2>/dev/null | grep -o "2\\.0" || echo "0")\r\nif [ "$HORISON_CHECK" == "2.0" ]; then\r\n    log_pass "Footstep prediction horizon: 2.0s (future collision prevention)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    log_fail "Prediction horizon not configured for humanoid gait"\r\nfi\r\n\r\n# Test 8-10: Dynamic Safety Systems\r\necho "\r\n\ud83d\udee1\ufe0f DYNAMIC SAFETY SYSTEM VALIDATION"\r\necho "-----------------------------------"\r\n\r\n# Safety response system activation\r\nSAFETY_STATUS=$(timeout 15 ros2 topic echo /humanoid/safety_status --once 2>/dev/null |\r\n    grep -o "ACTIVE\\|CAUTIOUS\\|CRITICAL" | head -1 || echo "UNKNOWN")\r\n\r\nif [ "$SAFETY_STATUS" == "ACTIVE" ] || [ "$SAFETY_STATUS" == "CAUTIOUS" ]; then\r\n    log_pass "Safety system status: $SAFETY_STATUS (active monitoring)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    log_fail "Safety monitoring status: $SAFETY_STATUS"\r\nfi\r\n\r\n# Validate students can explain differences\r\n# Create education check that confirms proper statements\r\nEDUCATION_CHECK="$(timeout 5 ros2 service call /test_humanoid_vs_wheeled std_srvs/srv/Trigger \'{\r\n  data: "List three ways humanoid obstacle avoidance differs from wheeled robots",\r\n  request_id: "student_understanding_001" }\' 2>/dev/null | grep -A 3 "humanoid_vs_wheeled" || echo "UNAVAILABLE")"\r\n\r\n# Final reporting and scoring system matches T comprehensive validation\r\necho "\r\n=========================================="\r\necho "\ud83d\udcca OBSTACLE AVOIDANCE VALIDATION RESULTS"\r\necho "=========================================="\r\n\r\nSCORE_PERCENT=$(echo "scale=1; $PASS_COUNT * 100 / $TOTAL_TESTS" | bc)\r\necho "Total Tests: $TOTAL_TESTS"\r\necho "Passed: $PASS_COUNT"\r\necho "Validation Score: ${SCORE_PERCENT}%"\r\n\r\nif (( $(echo "$SCORE_PERCENT >= 85" | bc -l) )); then\r\n    echo -e "\\n${GREEN}\ud83c\udfc6 HUMANOID OBSTACLE AVOIDANCE: VALIDATED SUCCESS${NC}"\r\n    echo "\u2705 Your avoidance system is suitable for humanoid bipedal navigation!"\r\n    echo "\u2705 Meets safety requirements for ceiling, torso, and footstep protection"\r\n    echo "\u2705 System ablates wheeled-robot assumptions, implements bipedal needs"\r\nelse\r\n    echo -e "\\n${RED}\u26a0\ufe0f  VALIDATION: NEEDS IMPROVEMENT${NC}"\r\n    echo "Some parameters outside safety limits for bipedal navigation"\r\n    echo "Review failed tests and reconfigure safety parameters"\r\nfi\r\n\r\necho "\r\n\ud83c\udf93 EDUCATIONAL ACHIEVEMENT:"echo "Students understand humanoid-specific obstacle requirements:"\r\necho "- 3D collision prediction beyond 2D wheeled models"\r\necho "- Head clearance protection for ceiling environments"\r\necho "- Torso rotation swept volumes during navigation"\r\necho "- Dynamic footstep projection with gait phase awareness"\r\necho "\u2713 Ready for systematic exterior input embrace \u2705"\n'})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>s});var o=r(6540);const a={},t=o.createContext(a);function i(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);