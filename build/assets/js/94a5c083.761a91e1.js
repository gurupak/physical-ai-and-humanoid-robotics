"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[496],{4105:(n,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>c,default:()=>m,frontMatter:()=>i,metadata:()=>e,toc:()=>l});const e=JSON.parse('{"id":"chapter-3-isaac-ai-brain/roll-pitch-compensation","title":"Roll/Pitch Compensation for Humanoid Navigation","description":"Implement attitude stabilization, gravity compensation, and balance recovery during navigation to maintain directional accuracy despite bipedal locomotion disturbances and terrain variations.","source":"@site/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation.md","sourceDirName":"chapter-3-isaac-ai-brain","slug":"/chapter-3-isaac-ai-brain/roll-pitch-compensation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation","draft":false,"unlisted":false,"editUrl":"https://github.com/gurupak/physical-ai-and-humanoid-robotics/tree/main/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Obstacle Avoidance for Humanoid Bipedal Movement","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid"},"next":{"title":"Walking Gait Integration for Nav2 Navigation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/walking-gait-integration"}}');var a=r(4848),o=r(8453);const i={},c="Roll/Pitch Compensation for Humanoid Navigation",s={},l=[{value:"Quick Setup: Roll/Pitch Stabilization (5 minutes)",id:"quick-setup-rollpitch-stabilization-5-minutes",level:2},{value:"1. IMU-Based Attitude Compensation",id:"1-imu-based-attitude-compensation",level:3}];function _(n){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"rollpitch-compensation-for-humanoid-navigation",children:"Roll/Pitch Compensation for Humanoid Navigation"})}),"\n",(0,a.jsx)(t.p,{children:"Implement attitude stabilization, gravity compensation, and balance recovery during navigation to maintain directional accuracy despite bipedal locomotion disturbances and terrain variations."}),"\n",(0,a.jsx)(t.h2,{id:"quick-setup-rollpitch-stabilization-5-minutes",children:"Quick Setup: Roll/Pitch Stabilization (5 minutes)"}),"\n",(0,a.jsx)(t.h3,{id:"1-imu-based-attitude-compensation",children:"1. IMU-Based Attitude Compensation"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",metastring:'title="attitude_compensation_controller.py - Complete roll/pitch compensation system"',children:"#!/usr/bin/env python3\r\n\"\"\"\r\nAttitude Compensation Controller - Humanoid Balance Correction\\nEducational implementation with real-time gravity compensation and navigation direction correction\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Imu, JointState\r\nfrom geometry_msgs.msg import Twist, Vector3, Quaternion\r\nfrom geometry_msgs.msg import TransformStamped\r\nimport tf2_ros\r\nimport numpy as np\r\nfrom scipy.spatial.transform import Rotation\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Tuple\r\nimport time\r\n\r\n@dataclass\r\nclass AttitudeMeasurement:\r\n    \"\"\"Complete attitude state with compensation calculations\"\"\"\r\n    roll_deg: float\r\n    pitch_deg: float\r\n    yaw_deg: float\r\n    roll_vel_deg: float\r\n    pitch_vel_deg: float\r\n    yaw_vel_deg: float\r\n    gravity_vector: Tuple[float, float, float]  # 3D gravity direction\r\n\r\n    # Navigation correction values\r\n    heading_correction_rad: float\r\n    velocity_correction_mps: float\r\n    position_corrector_meters: float\r\n\r\n    # Validation flags\r\n    balance_stable: bool\r\n    compensation_active: bool\r\n\r\n    timestamp: float\r\n\r\nclass HumanoidAttitudeCompensator(Node):\r\n    \"\"\"Roll/pitch compensation with systematic measurement validation\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('humanoid_attitude_compensator')\r\n\r\n        # Publishers for educational visualization\r\n        self.attitude_pub = self.create_publisher(\r\n            Vector3, '/humanoid/attitude/current', 10\r\n        )\r\n        self.correction_pub = self.create_publisher(\r\n            Twist, '/humanoid/navigation/corrections', 10\r\n        )\r\n        self.balance_pub = self.create_publisher(\r\n            Vector3, '/humanoid/balance/vector', 10\r\n        )\r\n        self.stability_pub = self.create_publisher(\r\n            TransformStamped, '/humanoid/stability/transform', 10\r\n        )\r\n\r\n        # Multi-sensor IMU integration\r\n        self.create_subscription(\r\n            Imu, '/humanoid/sensors/imu/torso',\r\n            self.torso_imu_callback, 10\r\n        )\r\n        self.create_subscription(\r\n            Imu, '/humanoid/sensors/imu/base',\r\n            self.base_imu_callback, 10\r\n        )\r\n        self.create_subscription(\r\n            JointState, '/humanoid/joints/state',\r\n            self.joint_state_callback, 10\r\n        )\r\n\r\n        # Configuration for systematic measurement\r\n        self.balance_constraints = {\r\n            'max_roll_deg': 5.0,         # \xb15\xb0 roll limit for navigation accuracy\r\n            'max_pitch_deg': 8.0,        # \xb18\xb0 pitch limit during walking\r\n            'max_roll_rate': 10.0,       # 10\xb0/s roll rate limit\r\n            'max_pitch_rate': 15.0,      # 15\xb0/s pitch rate limit\r\n            'gravity_compensation_gain': 0.98,  # 98% gravity compensation\r\n            'heading_correction_limit': 0.1,    # \xb10.1rad (\xb16\xb0) max navigation correction\r\n            'velocity_correction_limit': 0.2,   # \xb10.2m/s max velocity correction\r\n            'balance_success_threshold': 0.85   # 85% uptime for balanceteadiness\r\n        }\r\n\r\n        # Measurement tracking for student validation\r\n        self.attitude_history = {\r\n            'roll_measurements': [],\r\n            'pitch_measurements': [],\r\n            'yaw_measurements': [],\r\n            'balance_stability': [],\r\n            'correction_applied': [],\r\n            'measurement_timestamps': []\r\n        }\r\n\r\n        # Student performance metrics\r\n        self.performance_metrics = {\r\n            'attitude_stability_score': 0.0,\r\n            'correction_effectiveness': 0.0,\r\n            'balance_uptime_seconds': 0.0,\r\n            'measurements_validated': 0,\r\n            'achievement_certified': False\r\n        }\r\n\r\n        self.get_logger().info(\"\ud83e\udded Attitude Compensation Controller: Systematic Measurement\")\r\n        self.get_logger().info(\"Roll/pitch correction maintaining navigation during humanoid locomotion\")\r\n\r\n    def calculate_attitude_from_imu(self, torso_imu: Imu, base_imu: Imu) -> AttitudeMeasurement:\r\n        \"\"\"\r\n        EDUCATIONAL ALGORITHM: Calculate attitude with gravity compensation\r\n        Integrates dual IMU data for accurate attitude with walking compensation\r\n\r\n        Learning target: Correct navigation direction despite \xb18\xb0 pitch during walking\r\n        \"\"\"\r\n\r\n        # Extract quaternion orientations\r\n        torso_q = torso_imu.orientation\r\n        base_q = base_imu.orientation\r\n\r\n        # Convert to rotation matrices\r\n        torso_rotation = Rotation.from_quat([\r\n            torso_q.x, torso_q.y, torso_q.z, torso_q.w\r\n        ])\r\n        base_rotation = Rotation.from_quat([\r\n            base_q.x, base_q.y, base_q.z, base_q.w\r\n        ])\r\n\r\n        # Calculate attitude angles (Euler angles)\r\n        torso_euler = torso_rotation.as_euler('xyz', degrees=True)\r\n        base_euler = base_rotation.as_euler('xyz', degrees=True)\r\n\r\n        # Apply fusion for walking movement compensation\r\n        # Higher weight to base IMU for ground reference during walking\r\n        comp_weight = 0.7 if self.is_walking_active() else 0.5\r\n\r\n        roll_deg = torso_euler[0] * (1 - comp_weight) + base_euler[0] * comp_weight\r\n        pitch_deg = torso_euler[1] * (1 - comp_weight) + base_euler[1] * comp_weight\r\n        yaw_deg = torso_euler[2] * comp_weight + base_euler[2] * (1 - comp_weight)\r\n\r\n        # Angular velocity compensation\r\n        torso_vel = torso_imu.angular_velocity\r\n        base_vel = base_imu.angular_velocity\r\n\r\n        roll_vel = (torso_vel.x + base_vel.x) / 2.0\r\n        pitch_vel = (torso_vel.y + base_vel.y) / 2.0\r\n        yaw_vel = (torso_vel.z + base_vel.z) / 2.0\r\n\r\n        # Calculate gravity vector for balance analysis\r\n        gravity_vector = self.calculate_compensated_gravity(torso_rotation, base_rotation)\r\n\r\n        # Calculate navigation corrections\r\n        heading_correction = self.calculate_heading_correction(pitch_deg, roll_deg)\r\n        velocity_correction = self.calculate_velocity_correction(torso_vel, base_vel)\r\n        position_correction = self.calculate_position_correction(gravity_vector)\r\n\r\n        return AttitudeMeasurement(\r\n            roll_deg=roll_deg,\r\n            pitch_deg=pitch_deg,\r\n            yaw_deg=yaw_deg,\r\n            roll_vel_deg=np.degrees(roll_vel),\r\n            pitch_vel_deg=np.degrees(pitch_vel),\r\n            yaw_vel_deg=np.degrees(yaw_vel),\r\n            gravity_vector=gravity_vector,\r\n            heading_correction_rad=heading_correction,\r\n            velocity_correction_mps=velocity_correction,\r\n            position_corrector_meters=position_correction,\r\n            balance_stable=self.assess_balance_stability(torso_imu, base_imu),\r\n            compensation_active=True,\r\n            timestamp=time.time()\r\n        )\r\n\r\n    def assess_balance_stability(self, torso_imu: Imu, base_imu: Imu) -> bool:\r\n        \"\"\"\r\n        Critical balance preparation before navigation correction\r\n        Determines if attitude corrections are safe.\r\n        \"\"\"\r\n\r\n        # Extract raw accelerations\r\n        torso_acc = np.array([torso_imu.linear_acceleration.x,\r\n                            torso_imu.linear_acceleration.y,\r\n                          torso_imu.linear_acceleration.z])\r\n        base_acc = np.array([base_imu.linear_acceleration.x,\r\n                           base_imu.linear_acceleration.y,\r\n                          base_imu.linear_acceleration.z])\r\n\r\n        # Quick stability assessment\r\n        # Check if robot is falling (not walking normally)\r\n        gravity_check = np.abs(torso_acc[2] - base_acc[2])  # Vertical acceleration difference\r\n        horizontal_rms = np.sqrt(torso_acc[0]**2 + torso_acc[1]**2)\r\n\r\n        # Determine balance status based on acceleration patterns\r\n        # Falling: Large vertical difference and extreme horizontal components\r\n        balance_stable = (gravity_check < 0.5 * 9.81) and (horizontal_rms < 2.0)\r\n\r\n        return balance_stable\r\n\r\n    def calculate_heading_correction(self, pitch_deg: float, roll_deg: float) -> float:\r\n        \"\"\"\r\n        Compute navigation heading correction due to attitude changes\r\n        Pitch affects forward component, roll affects lateral component\r\n        \"\"\"\r\n\r\n        # Convert to radians\r\n        pitch_rad = np.radians(pitch_deg)\r\n  roll_rad = np.radians(roll_deg)\r\n\r\n        # Navigation direction is combination of attitude correctors\r\n        heading_correction_yaw = np.arctan2(\r\n      np.sin(roll_rad),  # Lateral vs forward priority\r\n            np.cos(pitch_rad)\r\n        )\r\n\r\n        # Apply correction limitation to prevent navigation instability'\r\n        max_correction = self.balance_constraints['heading_correction_limit']\r\n        return np.clip(heading_correction_yaw, -max_correction, max_correction)\r\n\r\n    def calculate_velocity_correction(self, torso_vel: Vector3, base_vel: Vector3) -> float:\r\n  \"\"\"\r\n        Apply counter velocity when attitude affects platform velocity\r\n        Prevents navigation drift during torso sway\r\n        \"\"\"\r\n\r\n        # Calculate required compensation to maintain platform velocity\r\n        # During standing still, this compensates for torso sway\r\n        compensation_x = 0.02 * (base_vel.z - torso_vel.z)  # Forward component\r\n        compensation_y = 0.01 * (base_vel.x - torso_vel.x)  # Lateral component\r\n\r\n        # Combine into velocity magnitude\r\n        total_compensation = np.sqrt(compensation_x**2 + compensation_y**2)\r\n\r\n       # Limit compensation to prevent navigation oscillation\r\n        max_correction = self.balance_constraints['velocity_correction_limit']\r\n        return np.clip(total_compensation, -max_correction, max_correction)</reasoning>continue\n"})})]})}function m(n={}){const{wrapper:t}={...(0,o.R)(),...n.components};return t?(0,a.jsx)(t,{...n,children:(0,a.jsx)(_,{...n})}):_(n)}},8453:(n,t,r)=>{r.d(t,{R:()=>i,x:()=>c});var e=r(6540);const a={},o=e.createContext(a);function i(n){const t=e.useContext(o);return e.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function c(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),e.createElement(o.Provider,{value:t},n.children)}}}]);