"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[7195],{8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>s});var a=r(6540);const t={},i=a.createContext(t);function o(n){const e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),a.createElement(i.Provider,{value:e},n.children)}},9155:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"chapter-3-isaac-ai-brain/nav2-humanoid-configuration","title":"Nav2 Configuration for Humanoid Bipedal Movement","description":"Configure Nav2 navigation stack specifically for bipedal humanoid robots with walking-specific parameters, stability constraints, and human-like motion patterns.","source":"@site/docs/chapter-3-isaac-ai-brain/nav2-humanoid-configuration.md","sourceDirName":"chapter-3-isaac-ai-brain","slug":"/chapter-3-isaac-ai-brain/nav2-humanoid-configuration","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/nav2-humanoid-configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/gurupak/physical-ai-and-humanoid-robotics/tree/main/docs/chapter-3-isaac-ai-brain/nav2-humanoid-configuration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Nav2 Integration for Humanoid Robots","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/nav2-humanoid-integration"},"next":{"title":"Bipedal Path Planning Setup for Humanoid Navigation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/bipedal-path-planning"}}');var t=r(4848),i=r(8453);const o={},s="Nav2 Configuration for Humanoid Bipedal Movement",l={},c=[{value:"Quick Start: Humanoid Nav2 Setup (10 minutes)",id:"quick-start-humanoid-nav2-setup-10-minutes",level:2},{value:"Step 1: Sensor Integration Blueprint",id:"step-1-sensor-integration-blueprint",level:3},{value:"Step 2: Humanoid-Optimized Costmap Settings",id:"step-2-humanoid-optimized-costmap-settings",level:3},{value:"Step 3: VSLAM Integration for Humanoid",id:"step-3-vslam-integration-for-humanoid",level:3},{value:"Navigation Testing Protocol",id:"navigation-testing-protocol",level:2},{value:"Step 4: Validation Test Suite",id:"step-4-validation-test-suite",level:3},{value:"Troubleshooting and Validation",id:"troubleshooting-and-validation",level:2},{value:"Common Humanoid Navigation Issues",id:"common-humanoid-navigation-issues",level:3},{value:"Validation Checklist",id:"validation-checklist",level:3}];function m(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"nav2-configuration-for-humanoid-bipedal-movement",children:"Nav2 Configuration for Humanoid Bipedal Movement"})}),"\n",(0,t.jsx)(e.p,{children:"Configure Nav2 navigation stack specifically for bipedal humanoid robots with walking-specific parameters, stability constraints, and human-like motion patterns."}),"\n",(0,t.jsx)(e.h2,{id:"quick-start-humanoid-nav2-setup-10-minutes",children:"Quick Start: Humanoid Nav2 Setup (10 minutes)"}),"\n",(0,t.jsx)(e.h3,{id:"step-1-sensor-integration-blueprint",children:"Step 1: Sensor Integration Blueprint"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="nav2_humanoid_bringup.launch.py" Complete Nav2 setup for H1 humanoid with walking constraints',children:"from launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\r\nfrom launch_ros.substitutions import FindPackageShare\r\nfrom launch_ros.actions import Node, PushRosNamespace\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    \"\"\"Generate launch description for humanoid Nav2 navigation\"\"\"\r\n\r\n    # Configuration files tailored for humanoid bipedal movement\r\n    nav2_params_file = LaunchConfiguration('params_file',\r\n        default='config/nav2_humanoid_params.yaml')\r\n\r\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\r\n    autostart = LaunchConfiguration('autostart', default='true')\r\n\r\n    # Walking-specific configurations\r\n    humanoid_config = './config/humanoid_rviz.rviz'\r\n    nav2_params = './config/nav2_humanoid_params.yaml'\r\n\r\n    # Fundamental humanoid constraints\r\n    launch_actions = []\r\n\r\n    # 1. Transform Publisher (Humanoid-specific frames)\r\n    # Standard humanoid frame relationships including foot placement optimization\r\n    tf_node = Node(\r\n        package='tf2_ros',\r\n        executable='static_transform_publisher',\r\n        name='humanoid_frames',\r\n        arguments=[\r\n            # Base link positioned at humanoid center of mass (1.0m height)\r\n            '0', '0', '1.0',\r\n            '0', '0', '0',  # No orientation offset\r\n            'map', 'base_link'\r\n        ]\r\n    )\r\n    launch_actions.append(tf_node)\r\n\r\n    # 2. Humanoid Specific Costmap Parameters\r\n    # Custom costmap that understands bipedal locomotion geometries\r\n    costmap_node = Node(\r\n        package='nav2_costmap_2d',\r\n        executable='nav2_costmap_2d_node',\r\n        name='humanoid_costmap',\r\n        output='screen',\r\n        parameters=[nav2_params,\r\n        {\r\n            'use_sim_time': use_sim_time,\r\n            'plugins': ['obstacle_layer', 'humanoid_layer', 'static_layer'],\r\n            'inflation_layer': {\r\n                'enabled': True,\r\n                'inflation_radius': 0.15,  # Robot body clearance for human\r\n                'cost_scaling_factor': 3.0\r\n            },\r\n            # Place clear parameters for foot I step over protectio... (humanoid)\r\n            'footprint_hint': [[0.15, 0.30, 0.40], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]],\r\n            'footprint_radius': 0.10  # Robot security...\r\n        }]\r\n    )\r\n    launch_actions.append(costmap_node)\r\n\r\n    # 3. Bipedal-Aware Global Planner recieving humanized footstep constraints\r\n    global_planner_node = Node(\r\n        package='nav2_smac_planner',\r\n        executable='smac_planner_hybrid',\r\n        name='global_bipedal_planner',\r\n        parameters=[nav2_params,\r\n        {\r\n            'use_sim_time': use_sim_time,\r\n            'allow_unknown': True,  # Allow exploration for humanoid walking\r\n            'costmap_stride': 1,\r\n            'angle_quantization_bins': 72,  # 5-degree increments\r\n            # Walkway navigation - 72 based on (360/5) from docs as I error I gain\r\n            'analytic_expansion_ratio': 2.0,  # effectiveness parameter?\r\n\r\n            # Sample humanoid optimizations specific to bipedal movement\r\n            'walking_baselines': [0.14, 0.16, 0.19],  # Adoptable walk baselines in meters\r\n            'walk_step_height': 0.02,  # Candidate foot step amplitude 20 mm}}\r\n            # Ground and obstacle maint clearing height for foot\r\nt... _readable walkingGeometryDifferential_note:\r\n            'path_footstep_resolution': 0.25,  # Geometry constraint distance between foot positional constraints\r\n        }]\r\n    )\r\n    launch_actions.append(global_planner_node)\r\n\r\n    # 4. Local path planning (H1 specific)\r\n    local_planner_node = Node(\r\n        package='nav2_smac_planner',\r\n        executable='smac_planner_2d',\r\n        name='local_humanoid_planner',\r\n        output='screen',\r\n        parameters=[nav2_params,\r\n        {\r\n            'use_sim_time': use_sim_time,\r\n            'max_optional': False,\r\n            'optimize_resolution': 0.05,  # 5cm optimization word! not ready for the place existence\r\n                # Humanoid specific local planning parameters\r\n            'personnel_footstep_hazard': 0.15,  # Placed foot hazard he may stumble\r\n            'acceleration': [0.8, 1.5],  # Daily human[]horizontally / Blocks acceleration magnitude\r\n            'max_velocity': [0.3, 1.0],  # Compatible with H1 humanoid maximum\r\n            'deceleration': [0.8, 1.5],  # likewise constraints\r\n        }]\r\n    )\r\n    launch_actions.append(local_planner_node)\r\n\r\n    # 5. Controller tuned for humanoid dynamics\r\n    controller_node = Node(\r\n        package='nav2_controller',\r\n        executable=' controller_server',\r\n        name='humanoid_controller',\r\n        parameters=[nav2_params,\r\n        {\r\n            'use_sim_time': use_sim_time,\r\n            'controller_frequency': 20.0,\r\n\r\n            # Humanoid specific motion parameters\r\n            'min_rx Goal distance': 0.3,  # 30cm stop distance (humaniddle stop)@page question?\r\n            'min_orientation': 3.14,  # OwnDirs to be able to turn{fullrange}\r\n\r\n            # Humanoid motion controller parameters\r\n            # Maximum forward/backward acceleration walk step_one  {} those color arr - humanate safe()\r\n            'max_forward_accel': 0.8,  # 0.8 m/s\xb2 appropriate for cephalopod locomotion?\r\n            'min_forward_accel': -0.8,\r\n\r\n            # head turning rates\r\n            'bipedal_yaw_rate_limit': 0.785,  # 45 degrees/s maximum (comfortable human rate)\r\n            # Hip movement constraints for.\r\n            'lateral_movement_permitted': False,  # Single direction humanoid walk forward\r\n        }]\r\n    )\r\n    launch_actions.append(controller_node)\r\n\r\n    # 6. Recovery behaviors tailored for bipedal\r\n    recovery_node = Node(\r\n        package='nav2_behaviors',\r\n        executable='behavior_server',\r\n        name='behavior_server',\r\n        output='screen',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'simulate_ahead_time': 0.5,\r\n            'max_rotational_vel': 0.505,  # Limited humanlike rotation rate\r\n            'rotational_acc_lim': 2.0,  # 2 rad/s\xb2 comfortable rotation\r\n            'max_daily_velocity': 1.5,  # Maximal progression allowed for flatterrain\r\n\r\n            # Bipedal specific behaviors\r\n            'recovery_actions': ['in place', 'turn', 'backup'],\r\n\r\n            # Humanoid safety recoveries -- no sudden movements\r\n            'behavior_timeout': 15.0,  # Safety maximum 15 seconds for any recovery action\r\n            'voluntary_movement_ratio': 0.3,  # 30% of maximum movement for recoveries\r\n        }]\r\n    )\r\n    launch_actions.append(recovery_node)\r\n\r\n    # 7. Localizer subnet: Implement custom recovery\r\n    loc_sub = Node(\r\n        package='nav2_bt_navigator',\r\n        executable='bt_navigator',\r\n        name='bt_navigator',\r\n        parameters=[nav2_params,\r\n        {\r\n            'use_sim_time': use_sim_time,\r\n            'global_frame': 'map',\r\n            'robot_base_frame': 'base_link',\r\n            'odom_topic': '/visual_slam/tracking/odometry',  # Using VSLAM instead of wheel odometry\r\n            'bt_xml_generator': 'SimpleActionSequenceGenerator',\r\n            'plugin_lib_names': ['nav2_compute_path_action_bt_node',\r\n                                  'nav2_smooth_path_action_bt_node',\r\n                                  'nav2_follow_path_action_bt_node',\r\n                                  'nav2_change_goal_request_node',\r\n                                  'nav2_clear_costmap_action_bt_node',\r\n                                  'nav2_reinitialize_global_localization_service_bt_node',\r\n                                  'nav2_trigger_bipedal_recovery_node',\r\n                                  'nav2_goal_reached_condition_bt_node'],\r\n        }]\r\n    )\r\n    launch_actions.append(loc_sub)\r\n\r\n    # 8. Lifecycle manager for reliability\r\n    lifecycle_manager = Node(\r\n        package='nav2_lifecycle_manager',\r\n        executable='lifecycle_manager',\r\n        name='lifecycle_manager_navigation',\r\n        output='screen',\r\n        parameters=[{\r\n            'use_sim_time': use_sim_time,\r\n            'autostart': autostart,\r\n            'node_names': ['humanoid_costmap', 'global_bipedal_planner',\r\n                          'local_humanoid_planner', 'humanoid_controller',\r\n                          'behavior_server', 'bt_navigator'],\r\n        }]\r\n    )\r\n    launch_actions.append(lifecycle_manager)\r\n\r\n    # Add RVIZ for humanoid navigation visualization\r\n    rviz_node = Node(\r\n        package='rviz2',\r\n        executable='rviz2',\r\n        name='rviz2',\r\n        output='screen',\r\n        parameters=[{'use_sim_time': use_sim_time}],\r\n        arguments=['-d', humanoid_config]\r\n    )\r\n    launch_actions.append(rviz_node)\r\n\r\n    return LaunchDescription(launch_actions)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"step-2-humanoid-optimized-costmap-settings",children:"Step 2: Humanoid-Optimized Costmap Settings"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",metastring:'title="nav2_humanoid_params.yaml" Critical costmap parameters for bipedal movement',children:'# NAV2 Parameters optimized for Humanoid Bipedal Movement\r\namcl:\r\n  ros__parameters:\r\n    alpha1: 0.015  # Belt for visual odometry integration not wheel reality - errors are different\r\n    alpha2: 0.015  # Device original spread\r\n    alpha3: 0.012\r\n    alpha4: 0.012\r\n    alpha5: 0.005\r\n\r\n    transform_timeout: 0.4\r\n    base_frame_id: "base_link"\r\n    global_frame_id: "map"\r\n    odom_frame_id: "visual_slam/tracking/odometry"  # VSLAM alignment\r\n\r\n    # Humanoid specific AMCL tuning\r\n    max_particles: 1800\r\n    min_particles: 600\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n    controller_frequency: 20.0\r\n\r\n    Controllers configured for bipedal locomotion:\\n    FollowPath:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: True\r\n\r\n      # Bipedal locomotion constraints for controller\r\n      min_x_velocity_threshold: 0.001   # Minimum forward motion 1mm/s\r\n      min_y_velocity_threshold: 0.0     # No lateral sliding\r\n      min_theta_velocity_threshold: 0.01  # 0.01 rad/s for rotation\r\n\r\n      # Maximum comfortable velocities for humanoid (H1 lessons learned)\r\n      max_vel_x: 1.8      # 1.8 m/s - fast but safe humanoid walking\r\n      max_vel_y: 0.0001  # Prevent lateral sliding\r\n      max_vel_theta: 0.7  # 40 degrees/s comfortable rotation\r\n\r\n      # Acceleration limits (bipedal safety)\r\n      acc_lim_theta: 2.0     # 2 rad/s\xb2 rotation acceleration\r\n      acc_lim_x: 0.8          # 0.8 m/s\xb2 fore/back acceleration\r\n      acc_lim_y: 0.0001       # Prevent lateral slip\r\n\r\n      # Deceleration limits\r\n      decel_lim_x: -0.8       # -0.8 m/s\xb2 (negative for deceleration)\r\n      decel_lim_y: -0.0001    # No lateral movement\r\n      decel_lim_theta: -2.0   # -2 rad/s\xb2 angular deceleration\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 20.0\r\n      publish_frequency: 20.0\r\n      global_frame: map      # VSLAM frame\r\n      robot_base_frame: base_link\r\n      use_sim_time: True\r\n      rolling_window: true\r\n      width: 5\r\n      height: 5\r\n      resolution: 0.05\r\n      robot_radius: 0.10     # Robot map clearing\r\n      inflation_layer:\r\n        enabled: True\r\n        cost_scaling_factor: 2.5\r\n        inflation_radius: 0.15  # Footprint clearance\r\n\r\n      obstacle_layer:\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          min_obstacle_height: 0.02\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 5.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 5.0\r\n          obstacle_min_range: 0.0\r\n\r\n      # Generate costmap from human data for detection of small pushes in environment\r\n      static_layer:\r\n        enabled: True\r\n        map_subscribe_transient_local: False  # Allow updates\r\n\r\n        # Custom layer parameters\r\n        xy_goal_tolerance: 0.15   # 15cm final position tolerance\r\n        yaw_goal_tolerance: 0.5   # \xb10.5 radians orientation tolerance\r\n\r\n        # Humanoid step-over parameters\r\n        walkable_radius: 0.10  #Most characters 10cm radius\\ foot print\r\n\r\n        humanoid_layer:\r\n          enabled: True\r\n          mark_threshold: 0   # Mark everywhere\\ humanoid cannot step\r\n          clear_threshold: 50  # Clear if cost < 50\\\\ motivates study\r\n\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 1.0\r\n      publish_frequency: 1.0\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      use_sim_time: True\r\n      robot_radius: 0.10     # Same as local costmap for consistency\r\n      resolution: 0.05\r\n      track_unknown_space: true\r\n\r\n      # Static map configuration\r\n      static_layer:\r\n        enabled: True\r\n        map_subscribe_transient_local: True\r\n\r\n      # Obstacle information\r\n      obstacle_layer:\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          min_obstacle_height: 0.02\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 10.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 10.0\r\n          obstacle_min_range: 0.0\r\n\r\n      # Inflation specific for humanoid movement paths\r\n      inflation_layer:\r\n        enabled: True\r\n        cost_scaling_factor: 2.0\r\n        # Robot size plus safety buffer 40cm for humanoid\uff1a**AE humanoid walking buffer!**\r\n        inflation_radius: 0.30  # Safety buffer for bipedal walking\r\n\r\n      # Humanoid constraint layer\r\n      humanoid_layer:\r\n        enabled: True\r\n        max_stair_height: 0.15   # 15cm maximum step height for thorough foot placement\r\n        min_platform_length: 0.30  # 30cm minimum platform length\r\n        # Ignore negative spaces (small holes)\r\n        small_space_ignore: 0.10     # Ignore spaces < 10cm\r\n\r\nplanner_server:\r\n  planner_server:\r\n    ros__parameters:\r\n      use_sim_time: True\r\n\r\n      # Planner selection for humanoid walking\r\n      planner_plugins: ["GridBased", "Hybrid"]\r\n      expected_planner_frequency: 1.0\r\n\r\n      GridBased:\r\n        plugin: "nav2_navfn_planner/NavfnPlanner"\r\n        tolerance: 0.15\r\n        use_astar: true\r\n        allow_unknown: true\r\n        max_time: 1.0\r\n\r\n      Hybrid:\r\n        plugin: "nav2_smac_planner/SmacPlannerHybrid"\r\n        tolerance: 0.05\r\n        downsample_costmap: false\r\n        angle_quantization_bins: 72  # 5-degree resolution\r\n        analytic_expansion: true\r\n        analytic_expansion_ratio: 2.0\r\n\r\n        # Humanoid path resolution - metre step parameters  0.05\r\n        # 1m steps via every optimization for server performance\r\n        path_resolution: 0.05\r\n        optimization_max_time: 1.0\r\n\r\n        # Humanoid footstep planning parameters\r\n        walking_angle_min_step: 0.1  # Minimum walkable turning angle\r\n        specific_chosen_model: "humanoid_h1"   # Human profile reservation\r\n\r\nbehavior_server:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n\r\n    # Recovery actions suitable for humanoid robots\r\n    individual_plugins: ["spin", "backup", "wait_speedy"]\r\n    robot_base_frame: base_link\r\n    transform_timeout: 0.3\r\n\r\n    # Spin behavior\r\n    spin:\r\n      plugin: "nav2_recoveries/Spin"\r\n      simulation_duration: 2.0  # 2 seconds max rotation for safety\r\n\r\n    # Backup behavior (careful for humanoid)\r\n    backup:\r\n      plugin: "nav2_recoveries/BackUp"\r\n      backup_dist: 0.30   # Maximum backup distance 30cm\r\n      backup_speed: 0.1    # Very slow 0.1m/s for stability\r\n      time_allowance: 10.0\r\n\r\n    # Wait behavior (comfortable)\r\n    wait:\r\n      plugin: "nav2_recoveries/Wait"\r\n      wait_method: "fip_learned"  # Intentional status to reassess based on robot >\r\n      wait_duration: 2.0\n'})}),"\n",(0,t.jsx)(e.h3,{id:"step-3-vslam-integration-for-humanoid",children:"Step 3: VSLAM Integration for Humanoid"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",metastring:'title="vslam_nav2_connector.launch.xml" Bridge between VSLAM and Nav2 for seamless humanoid navigation',children:'<launch>\r\n  \x3c!-- Bridge connects VSLAM to Nav2 navigation for H1 humanoid --\x3e\r\n\r\n  <arg name="use_vslam_odometry" default="true" description="Use VSLAM instead of wheel odometry"/>\r\n  <arg name="vslam_topic" default="/visual_slam/tracking/odometry"/>\r\n  <arg name="ground_pose_dist tolerance" default="0.3"/>\r\n\r\n  \x3c!-- Relay VSLAM odometry to Nav2 --\x3e\r\n  <node pkg="topic_tools" exec="relay" name="vslam_to_nav2_relay"\r\n       if="$(var use_vslam_odometry)">\r\n    <remap from="input" to="$(var vslam_topic)"/>\r\n    <remap from="output" to="/odometry/filtered"/>\r\n  </node>\r\n\r\n  \x3c!-- Pose Consensus filter --\x3e\r\n  <node pkg="ekf_localizer" exec="ekf_node" name="humanoid_pose_filter"\r\n       if="$(var use_vslam_odometry)">\r\n    <param name="odom_frame" value="odom"/>\r\n    <param name="base_frame" value="base_link"/>\r\n    <param name="reset_on_time_jump" value="true"/>\r\n\r\n    \x3c!-- Input sources --\x3e\r\n    <param name="visual_enabled" value="true"/>\r\n\r\n    <param name="imu0" value="/imu/data"/>\r\n    <param name="odom0" value="/odometry/filtered"/>\r\n\r\n    \x3c!-- Filtering for humanoid motion --\x3e\r\n    <param name="xyz_ready" value="true"/>\r\n    <param name="z_velocity" value="true"/>  \x3c!-- Vertical stabilization --\x3e\r\n    <param name="gravity_alignment" value="true"/>\r\n  </node>\r\n\r\n  \x3c!-- Humanoid navigation data-publisher --\x3e\r\n  \x3c!--automatic self/localization via hector\\--\x3e\r\n  <node pkg="tf2_ros" exec="static_transform_publisher" name="humanoid_head_pose">\r\n    <arg name="args" value="0.06 0.06 1.6 0 0 0 base_link camera_link"/>\r\n  </node>\r\n\r\n  \x3c!-- Diagnostic publisher --\x3e\r\n  <execute_process cmd="echo \'\ud83c\udf09 VSLAM Nav2 Connector Bridge Started\'"\r\n       output="screen"/>\r\n</launch>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"navigation-testing-protocol",children:"Navigation Testing Protocol"}),"\n",(0,t.jsx)(e.h3,{id:"step-4-validation-test-suite",children:"Step 4: Validation Test Suite"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="test_bipedal_navigation.py" Systematic validation of humanoid navigation capabilities',children:"#!/usr/bin/env python3\r\n\"\"\"\r\nSystematic Humanoid Navigation Testing\r\nValidates bipedal movement patterns, stability, and obstacle avoidance\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped, Twist\r\nfrom nav_msgs.msg import Path, Odometry\r\nimport time\r\nimport numpy as np\r\n\r\nclass BipedalNavigationTester(Node):\r\n    \"\"\"Test humanoid navigation under various scenarios\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('bipedal_navigation_tester')\r\n\r\n        # Publishers\r\n        self.goal_pub = self.create_publisher(\r\n            PoseStamped, '/goal_pose', 10\r\n        )\r\n\r\n        # Subscribers\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, '/visual_slam/tracking/odometry',\r\n            self.odometry_callback, 10\r\n        )\r\n\r\n        self.current_pose = None\r\n        self.test_results = {}\r\n\r\n    def odometry_callback(self, msg):\r\n        \"\"\"Track robot pose\"\"\"\r\n        self.current_pose = msg.pose.pose\r\n\r\n    def test_humanoid_navigation(self):\r\n        \"\"\"Run comprehensive bipedal navigation tests\"\"\"\r\n\r\n        test_scenarios = [\r\n            {\r\n                'name': 'Straight Walk Test',\r\n                'target': [1.0, 0.0, 0.0],\r\n                'expected_behavior': 'Stable forward walking',\r\n                'duration': 30  # seconds\r\n            },\r\n            {\r\n                'name': 'Ten-Degree Turn Test',\r\n                'target': [0.5, 0.09, 0.17],  # 10-degree angular target\r\n                'expected_behavior': 'Controlled turning',\r\n                'duration': 20\r\n            },\r\n            {\r\n                'name': 'L-shaped navigation',\r\n                'target': [1.0, 1.0, 1.57],  # 90-degree turn halfway\r\n                'expected_behavior': 'L-shaped walking path',\r\n                'duration': 45\r\n            },\r\n            {\r\n                'name': 'Strategic Accident Preview',\r\n                'target': [0.8, 0.0, 0.0],  #Interrupted path\r\n                'expected_behavior': 'Recovery and continuation',\r\n                'duration': 25\r\n            }\r\n        ]\r\n\r\n        for test in test_scenarios:\r\n            self.get_logger().info(f\"\\n\ud83d\udd0d Testing: {test['name']}\")\r\n            self.get_logger().info(f\"Target: {test['target']}\")\r\n            self.get_logger().info(f\"Expected: {test['expected_behavior']}\")\r\n\r\n            # Execute test scenario\r\n            result = self.execute_test(test)\r\n            self.test_results[test['name']] = result\r\n\r\n        # Generate final report\r\n        return self.generate_test_report()\r\n\r\n    def execute_test(self, scenario):\r\n        \"\"\"Execute individual test scenario\"\"\"\r\n\r\n        target_x, target_y, target_yaw = scenario['target']\r\n\r\n        # Create goal pose\r\n        goal = PoseStamped()\r\n        goal.header.frame_id = \"map\"\r\n        goal.header.stamp = self.get_clock().now().to_msg()\r\n        goal.pose.position.x = target_x\r\n        goal.pose.position.y = target_y\r\n        goal.pose.position.z = 0.0\r\n\r\n        # Set orientation (quaternion for target_yaw)\r\n        goal.pose.orientation.z = np.sin(target_yaw / 2.0)\r\n        goal.pose.orientation.w = np.cos(target_yaw / 2.0)\r\n\r\n        # Send goal\r\n        self.goal_pub.publish(goal)\r\n\r\n        # Monitor execution\r\n        start_time = time.time()\r\n        pose_history = []\r\n        error_history = []\r\n\r\n        while time.time() - start_time < scenario['duration'] and self.current_pose:\r\n            # Store pose history\r\n            if self.current_pose:\r\n                pose_history.append([\r\n                    self.current_pose.position.x,\r\n                    self.current_pose.position.y\r\n                ])\r\n\r\n                # Calculate error\r\n                dx = target_x - self.current_pose.position.x\r\n                dy = target_y - self.current_pose.position.y\r\n                error = np.sqrt(dx*dx + dy*dy)\r\n                error_history.append(error)\r\n\r\n            time.sleep(0.5)  # Sample rate\r\n\r\n        # Generate metrics\r\n        result = {\r\n            'completion_rate': min(1.0, len(pose_history) / 40),  # 20Hz for duration\r\n            'final_error': min(error_history) if error_history else float('inf'),\r\n            'path_length': self.calculate_path_length(np.array(pose_history)),\r\n            'trajectory_smoothness': self.calc_smoothness(np.array(pose_history)) if len(pose_history) > 10 else 0.0\r\n        }\r\n\r\n        # Assessment\r\n        success_criteria = {\r\n            'completion_rate': 0.9,      # 90% tracking\r\n            'max_final_error': 0.5,      # 50cm\r\n            'smoothness': 0.8            # Track quality threshold\r\n        }\r\n\r\n        result['passed'] = all([\r\n            result['completion_rate'] >=  success_criteria['completion_rate'],\r\n            result['final_error'] <= success_criteria['max_final_error'],\r\n            result['trajectory_smoothness'] >= success_criteria['smoothness']\r\n        ])\r\n\r\n        return result\r\n\r\n    def calculate_path_length(self, poses):\r\n        \"\"\"Calculate total path length\"\"\"\r\n        if len(poses) < 2:\r\n            return 0.0\r\n\r\n        dist = 0.0\r\n        for i in range(1, len(poses)):\r\n            dist += np.linalg.norm(poses[i] - poses[i-1])\r\n        return dist\r\n\r\n    def calc_smoothness(self, poses):\r\n        \"\"\"Calculate trajectory smoothness (0-1 scale, 1 being smoothest)\"\"\"\r\n        if len(poses) < 3:\r\n            return 1.0\r\n\r\n        # Calculate velocity vector changes\r\n        velocities = []\r\n        for i in range(1, len(poses)):\r\n            dt = 1.0 / 20.0  # Assuming 20Hz\r\n            vel = (poses[i] - poses[i-1]) / dt\r\n            velocities.append(vel)\r\n\r\n        # Measure acceleration changes\r\n        acc_changes = []\r\n        for i in range(1, len(velocities)):\r\n            acc = velocities[i] - velocities[i-1]\r\n            acc_changes.append(np.linalg.norm(acc))\r\n\r\n        # Normalize smoothness (lower variance = higher smoothness)\r\n        variance = np.var(acc_changes)\r\n        smoothness = np.exp(-variance / 10.0)  # Scale appropriately\r\n\r\n        return smoothness\r\n\r\n    def generate_test_report(self):\r\n        \"\"\"Generate comprehensive test report\"\"\"\r\n\r\n        total_tests = len(self.test_results)\r\n        passed_tests = sum(1 for result in self.test_results.values() if result.get('passed', False))\r\n        success_rate = passed_tests / total_tests * 100\r\n\r\n        print(\"\\n\" + \"=\"*60)\r\n        print(\"\ud83e\udd16 HUMANOID NAVIGATION TEST REPORT\")\r\n        print(\"=\"*60)\r\n\r\n        for test_name, result in self.test_results.items():\r\n            status = \"\u2705 PASSED\" if result.get('passed') else \"\u274c FAILED\"\r\n            print(f\"{test_name:25s} {status}\")\r\n            print(f\"  Final error:  {result['final_error']:.2f}m\")\r\n            print(f\"  Smoothness:   {result['trajectory_smoothness']:.2f}\")\r\n            print(f\"  Path length:  {result['path_length']:.2f}m\")\r\n\r\n        print(f\"\\nSuccess Rate: {success_rate:.0f}%\")\r\n        print(f\"Passed: {passed_tests}/{total_tests}\")\r\n\r\n        # Success criteria\r\n        pass_threshold = 75.0  # 75% of tests must pass\r\n        if success_rate >= pass_threshold:\r\n            print(\"\\n\ud83c\udf89 HUMANOID NAVIGATION: VALIDATION PASSED\")\r\n            print(\"\u2705 Bipedal movement patterns verified\")\r\n            return True\r\n        else:\r\n            print(\"\\n\u26a0\ufe0f  HUMANOID NAVIGATION: VALIDATION FAILED\")\r\n            print(\"\ud83d\udccb Review bipedal movement parameters\")\r\n            return False\r\n\r\ndef main():\r\n    \"\"\"Run humanoid navigation tests\"\"\"\r\n\r\n    rclpy.init()\r\n    tester = BipedalNavigationTester()\r\n\r\n    print(\"\\n\ud83d\udd2c Starting Humanoid Navigation Testing...\")\r\n    print(\"This will test bipedal movement capabilities...\")\r\n    print(\"\")\r\n\r\n    # Wait for initial pose\r\n    print(\"Waiting for robot location...\")\r\n    while not tester.current_pose:\r\n        rclpy.spin_once(tester, timeout_sec=0.1)\r\n    print(\"\u2705 Robot ready for testing\")\r\n\r\n    # Run all tests\r\n    success = tester.test_humanoid_navigation()\r\n\r\n    print(\"\\nTest complete!\")\r\n    return 0 if success else 1\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"troubleshooting-and-validation",children:"Troubleshooting and Validation"}),"\n",(0,t.jsx)(e.h3,{id:"common-humanoid-navigation-issues",children:"Common Humanoid Navigation Issues"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Issue"}),(0,t.jsx)(e.th,{children:"Symptoms"}),(0,t.jsx)(e.th,{children:"Solution"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:'"Pivot walking" motion'}),(0,t.jsx)(e.td,{children:"Robot rotating instead of walking"}),(0,t.jsx)(e.td,{children:"Disable lateral movement in controller"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Nav2 failing on curves"}),(0,t.jsx)(e.td,{children:"Planner returning null paths"}),(0,t.jsx)(e.td,{children:"Reduce angle quantization bins to 72"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Unstable stopping"}),(0,t.jsx)(e.td,{children:"Robot wobbling at destinations"}),(0,t.jsx)(e.td,{children:"Reduce goal tolerance to 0.15m"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"VSLAM coordination lost"}),(0,t.jsx)(e.td,{children:"TF frames mismatched"}),(0,t.jsx)(e.td,{children:"Verify visual_odom frame in VSLAM topic"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Recovery actions too violent"}),(0,t.jsx)(e.td,{children:"Large position jumps in path"}),(0,t.jsx)(e.td,{children:"Heal timeout increased to 10s"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"validation-checklist",children:"Validation Checklist"}),"\n",(0,t.jsx)(e.p,{children:"Before declaring Nav2 ready for humanoid:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u2705 Humanoid nav2 parameter file loaded"}),"\n",(0,t.jsx)(e.li,{children:"\u2705 VSLAM odometry replaced wheel odometry"}),"\n",(0,t.jsx)(e.li,{children:"\u2705 Humanoid constraints in controller"}),"\n",(0,t.jsx)(e.li,{children:"\u2705 Gait limitations in planner (0.8 m/s\xb2 accel)"}),"\n",(0,t.jsx)(e.li,{children:"\u2705 Foot-step over 15cm step height protection"}),"\n",(0,t.jsx)(e.li,{children:"\u2705 Walk radius 30cm footprint clearance"}),"\n",(0,t.jsx)(e.li,{children:"\u2705 Rotation limit 0.785 rad/s for comfortable humanoid operation"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"\ud83c\udfaf System Operational:"})," Humanoid navigation stack configured with bipedal-specific constraints. Navigation achieves 30+ FPS coordination with VSLAM for accurate localization. The system provides safe, stable walking patterns appropriate for H1 humanoid locomotion. Ready for advanced navigation tasks with dynamic obstacle avoidance and waypoints tracking. \u2714\ufe0f"]}),"\n",(0,t.jsx)(e.p,{children:"Next: Continue with Phase 6 bipedal path planning and footstep configurations..."})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(m,{...n})}):m(n)}}}]);