"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[1823],{4041:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"chapter-3-isaac-ai-brain/stereo-setup","title":"Stereo Camera Setup and Calibration for Humanoid VSLAM","description":"This guide walks through configuring stereo cameras specifically for humanoid robot VSLAM applications, focusing on hardware selection, geometric calibration, and Real-time performance validation.","source":"@site/docs/chapter-3-isaac-ai-brain/stereo-setup.md","sourceDirName":"chapter-3-isaac-ai-brain","slug":"/chapter-3-isaac-ai-brain/stereo-setup","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/stereo-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/gurupak/physical-ai-and-humanoid-robotics/tree/main/docs/chapter-3-isaac-ai-brain/stereo-setup.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS VSLAM Implementation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/isaac-ros-vslam-implementation"},"next":{"title":"VSLAM Integration with Humanoid Navigation Stack","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/vslam-integration"}}');var i=n(4848),t=n(8453);const s={},o="Stereo Camera Setup and Calibration for Humanoid VSLAM",c={},l=[{value:"Hardware Selection for Humanoid VSLAM",id:"hardware-selection-for-humanoid-vslam",level:2},{value:"Camera Requirements Analysis",id:"camera-requirements-analysis",level:3},{value:"Resolution Requirements",id:"resolution-requirements",level:4},{value:"Geometric Precision",id:"geometric-precision",level:4},{value:"Cost-Effective Camera Options",id:"cost-effective-camera-options",level:3},{value:"System Configuration",id:"system-configuration",level:2},{value:"Step 1: Dual Camera Mounting",id:"step-1-dual-camera-mounting",level:3},{value:"Hardware Assembly - Example Photos",id:"hardware-assembly---example-photos",level:3},{value:"Software Setup",id:"software-setup",level:2},{value:"Step 2: Install Isaac ROS Dependencies",id:"step-2-install-isaac-ros-dependencies",level:3},{value:"Step 3: Camera Connection Test",id:"step-3-camera-connection-test",level:3},{value:"Calibration Procedure",id:"calibration-procedure",level:2},{value:"Step 4: Generate Calibration Board",id:"step-4-generate-calibration-board",level:3}];function m(e){const r={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"stereo-camera-setup-and-calibration-for-humanoid-vslam",children:"Stereo Camera Setup and Calibration for Humanoid VSLAM"})}),"\n",(0,i.jsx)(r.p,{children:"This guide walks through configuring stereo cameras specifically for humanoid robot VSLAM applications, focusing on hardware selection, geometric calibration, and Real-time performance validation."}),"\n",(0,i.jsx)(r.h2,{id:"hardware-selection-for-humanoid-vslam",children:"Hardware Selection for Humanoid VSLAM"}),"\n",(0,i.jsx)(r.h3,{id:"camera-requirements-analysis",children:"Camera Requirements Analysis"}),"\n",(0,i.jsx)(r.p,{children:"For robust VSLAM on humanoid robots, cameras must meet these critical specifications:"}),"\n",(0,i.jsx)(r.h4,{id:"resolution-requirements",children:"Resolution Requirements"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Minimum"}),": 640\xd7480 @ 30 FPS (entry-level)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Recommended"}),": 1920\xd71080 @ 60 FPS (RTX 3060+)"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Optimal"}),": 3840\xd72160 @ 30-60 FPS (RTX 4090)"]}),"\n"]}),"\n",(0,i.jsx)(r.h4,{id:"geometric-precision",children:"Geometric Precision"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Baseline accuracy"}),": \u2264 0.1 mm standard deviation"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Synchronization error"}),": \u2264 1 millisecond"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Lens distortion"}),": \u2265 50% overlap between views"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"cost-effective-camera-options",children:"Cost-Effective Camera Options"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-markdown",children:"| Camera Model | Cost | Resolution | Max FPS | RTX Recommended |\r\n|----------|------|------------|---------|----------------|\r\n| **RealSense D455** | $250 | 1280\xd7720 | 90 | RTX 3060+ |\r\n| **ZED Mini** | $450 | 2560\xd7720 | 120 | RTX 4080+ |\r\n| **Stereolabs ZED X*** | $650 | 3840\xd71080* | 100+ | RTX 4090 |\r\n| **Dual Logitech Cinematic** | $160 | 1920\xd71080 | 60 | RTX 4060+ |\n"})}),"\n",(0,i.jsx)(r.p,{children:"*For production systems, I recommend ZED X for its CUDA acceleration"}),"\n",(0,i.jsx)(r.h2,{id:"system-configuration",children:"System Configuration"}),"\n",(0,i.jsx)(r.h3,{id:"step-1-dual-camera-mounting",children:"Step 1: Dual Camera Mounting"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",metastring:'title="assemble whichereotype_camera_rig while_assure_synchron\u201d}',children:'#!/bin/bash\r\n# Hardware Mounting Script for Humanoid Application\r\n\r\necho "=== Stereo Camera Hardware Assembly for H1 Humanoid ==="\r\n\r\n# Mounting specifications (matches H1 humanoid head position)\r\nBASELINE=0.12  # 120mm - human-like eye separation\r\nCAM_HEIGHT=1.6  # At humanoid head level (1.6m)\r\nCAM_DISTANCE=2.0  # Distance base from humanoid head\r\n\r\n# DisAssembly Instructions\r\nassembly_steps() {\r\n    echo "1. Position cameras horizontally on mounting bar"\r\n    echo "   - Mount point: N at $BASELINE"\r\n    echo "   - Alignment: \xb10.1mm baseline measurement critical"\r\n    echo "   - Height: $CAM_HEIGHT with \xb12cm precision"\r\n    echo\r\n    echo "2. Verify cabling and connections"\r\n    echo "   - USB3 parallelism for bandwidth"\r\n    echo "   - Trigger cable for hardware sync"\r\n    echo "   - Separate USB controllers if possible"\r\n    echo\r\n    echo "3. Synchronisation setup"\r\n    echo "   - Hardware trigger required (not software)"\r\n    echo "   - Jitter <1ms between frames essential"\r\n    echo "   - Use PTP (Precision Time Protocol) for software sync"\r\n}\r\n\r\nassembly_steps\n'})}),"\n",(0,i.jsx)(r.h3,{id:"hardware-assembly---example-photos",children:"Hardware Assembly - Example Photos"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.em,{children:"Example: Proper camera alignment for H1 humanoid application (image placeholder)"})}),"\n",(0,i.jsx)(r.h2,{id:"software-setup",children:"Software Setup"}),"\n",(0,i.jsx)(r.h3,{id:"step-2-install-isaac-ros-dependencies",children:"Step 2: Install Isaac ROS Dependencies"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",children:"# Install via apt\r\nsudo apt update && sudo apt install -y \\\r\n    ros-humble-isaac-ros-camera \\\r\n    ros-humble-isaac-ros-image-tools \\\r\n    ros-humble-isaac-ros-stereo \\\r\n    ros-humble-stereo-msgs \\\r\n    ros-humble-image-geometry \\\r\n    ros-humble-camera-calibration\r\n\r\n# Install calibration utilities\r\nsudo apt install -y \\\r\n    python3-opencv \\\r\n    python3-pykml \\\r\n    ros-humble-sensor-msgs \\\r\n    ros-humble-isaac-ros-camera-calibration\n"})}),"\n",(0,i.jsx)(r.h3,{id:"step-3-camera-connection-test",children:"Step 3: Camera Connection Test"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",metastring:'title="camera_connection_test.py"',children:'import cv2\r\nimport numpy as np\r\ndeftest_camera_connection():\r\n    """Test stereo camera hardware functionality for humanoid application"""\r\n\r\n    # Test basic connectivity\r\n    left = cv2.VideoCapture()  # left_cam = 0\r\n    right = cv2.VideoCapture()  # right_cam = 1\r\n\r\n    # Verify capture\r\n    success, left_frame = left.read()\r\n    success_right, right_frame = right.read()\r\n\r\n    assert success and success_right, "Camera hardware test failed"\r\n\r\n    print(f"Left camera: {left_frame.shape} @ {int(left.get(cv2.CAP_PROP_FPS))} FPS")\r\n    print(f"Right camera: {right_frame.shape} @ {int(right.get(cv2.CAP_PROP_FPS))} FPS")\r\n\r\n    # Verify synchronization\r\n    import time\r\n    start_time = time.time()\r\n    elapsed = 0\r\n    max_frames = 100\r\n\r\n    frame_counter = 0\r\n    while elapsed < 30:  # 30 second test\r\n        left_success = left.grab()\r\n        right_success = right.grab()\r\n        if left_success and right_success:\r\n            frame_counter += 1\r\n        else:\r\n            print("\u23f3 Synchronization issue detected")\r\n\r\n        elapsed = time.time() - start_time\r\n\r\n    print(f"Captured {frame_counter} synchronized pairs in {elapsed:.1f} seconds")\r\n    print(f"Synchronization rate: {frame_counter/elapsed:.1f} FPS")\r\n\r\n    return frame_counter >= (max_frames * 0.95)  # 95% sync test\r\n\r\n# Run test\r\nif __name__ == "__main__":\r\n    if test_camera_connection():\r\n        print("\\n\u2705 Camera hardware test PASSED")\r\n    else:\r\n        print("\\n\u274c Camera hardware test FAILED (recommended replace)")\n'})}),"\n",(0,i.jsx)(r.h2,{id:"calibration-procedure",children:"Calibration Procedure"}),"\n",(0,i.jsx)(r.h3,{id:"step-4-generate-calibration-board",children:"Step 4: Generate Calibration Board"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",metastring:'title="create_calibration_board_for_humanoid.py"',children:'import numpy as np\r\nimport cv2\r\nfrom PIL import Image, ImageDraw\r\n\r\ndef create_flat_calibration_board_suitable_for_humanoid_workspace(pattern_type="checkerboard",\r\n                                                                  board_size=(9, 6),\r\n                                                                  square_size_cm=2.5,\r\n                                                                  working_area="1.2m"):\r\n    """Creates calibration target suitable for\n'})})]})}function d(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>o});var a=n(6540);const i={},t=a.createContext(i);function s(e){const r=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(t.Provider,{value:r},e.children)}}}]);