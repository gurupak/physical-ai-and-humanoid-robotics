"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[496],{4105:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>s,contentTitle:()=>c,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"chapter-3-isaac-ai-brain/roll-pitch-compensation","title":"Roll/Pitch Compensation for Humanoid Navigation","description":"Implement attitude stabilization, gravity compensation, and balance recovery during navigation to maintain directional accuracy despite bipedal locomotion disturbances and terrain variations.","source":"@site/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation.md","sourceDirName":"chapter-3-isaac-ai-brain","slug":"/chapter-3-isaac-ai-brain/roll-pitch-compensation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation","draft":false,"unlisted":false,"editUrl":"https://github.com/gurupak/physical-ai-and-humanoid-robotics/tree/main/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Obstacle Avoidance for Humanoid Bipedal Movement","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid"},"next":{"title":"Walking Gait Integration for Nav2 Navigation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/walking-gait-integration"}}');var o=e(4848),i=e(8453);const r={},c="Roll/Pitch Compensation for Humanoid Navigation",s={},l=[{value:"Quick Setup: Roll/Pitch Stabilization (5 minutes)",id:"quick-setup-rollpitch-stabilization-5-minutes",level:2},{value:"1. IMU-Based Attitude Compensation",id:"1-imu-based-attitude-compensation",level:3}];function _(n){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"rollpitch-compensation-for-humanoid-navigation",children:"Roll/Pitch Compensation for Humanoid Navigation"})}),"\n",(0,o.jsx)(t.p,{children:"Implement attitude stabilization, gravity compensation, and balance recovery during navigation to maintain directional accuracy despite bipedal locomotion disturbances and terrain variations."}),"\n",(0,o.jsx)(t.h2,{id:"quick-setup-rollpitch-stabilization-5-minutes",children:"Quick Setup: Roll/Pitch Stabilization (5 minutes)"}),"\n",(0,o.jsx)(t.h3,{id:"1-imu-based-attitude-compensation",children:"1. IMU-Based Attitude Compensation"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",metastring:'title="attitude_compensation_controller.py - Complete roll/pitch compensation system"',children:"#!/usr/bin/env python3\n\"\"\"\nAttitude Compensation Controller - Humanoid Balance Correction\\nEducational implementation with real-time gravity compensation and navigation direction correction\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu, JointState\nfrom geometry_msgs.msg import Twist, Vector3, Quaternion\nfrom geometry_msgs.msg import TransformStamped\nimport tf2_ros\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nimport time\n\n@dataclass\nclass AttitudeMeasurement:\n    \"\"\"Complete attitude state with compensation calculations\"\"\"\n    roll_deg: float\n    pitch_deg: float\n    yaw_deg: float\n    roll_vel_deg: float\n    pitch_vel_deg: float\n    yaw_vel_deg: float\n    gravity_vector: Tuple[float, float, float]  # 3D gravity direction\n\n    # Navigation correction values\n    heading_correction_rad: float\n    velocity_correction_mps: float\n    position_corrector_meters: float\n\n    # Validation flags\n    balance_stable: bool\n    compensation_active: bool\n\n    timestamp: float\n\nclass HumanoidAttitudeCompensator(Node):\n    \"\"\"Roll/pitch compensation with systematic measurement validation\"\"\"\n\n    def __init__(self):\n        super().__init__('humanoid_attitude_compensator')\n\n        # Publishers for educational visualization\n        self.attitude_pub = self.create_publisher(\n            Vector3, '/humanoid/attitude/current', 10\n        )\n        self.correction_pub = self.create_publisher(\n            Twist, '/humanoid/navigation/corrections', 10\n        )\n        self.balance_pub = self.create_publisher(\n            Vector3, '/humanoid/balance/vector', 10\n        )\n        self.stability_pub = self.create_publisher(\n            TransformStamped, '/humanoid/stability/transform', 10\n        )\n\n        # Multi-sensor IMU integration\n        self.create_subscription(\n            Imu, '/humanoid/sensors/imu/torso',\n            self.torso_imu_callback, 10\n        )\n        self.create_subscription(\n            Imu, '/humanoid/sensors/imu/base',\n            self.base_imu_callback, 10\n        )\n        self.create_subscription(\n            JointState, '/humanoid/joints/state',\n            self.joint_state_callback, 10\n        )\n\n        # Configuration for systematic measurement\n        self.balance_constraints = {\n            'max_roll_deg': 5.0,         # \xb15\xb0 roll limit for navigation accuracy\n            'max_pitch_deg': 8.0,        # \xb18\xb0 pitch limit during walking\n            'max_roll_rate': 10.0,       # 10\xb0/s roll rate limit\n            'max_pitch_rate': 15.0,      # 15\xb0/s pitch rate limit\n            'gravity_compensation_gain': 0.98,  # 98% gravity compensation\n            'heading_correction_limit': 0.1,    # \xb10.1rad (\xb16\xb0) max navigation correction\n            'velocity_correction_limit': 0.2,   # \xb10.2m/s max velocity correction\n            'balance_success_threshold': 0.85   # 85% uptime for balanceteadiness\n        }\n\n        # Measurement tracking for student validation\n        self.attitude_history = {\n            'roll_measurements': [],\n            'pitch_measurements': [],\n            'yaw_measurements': [],\n            'balance_stability': [],\n            'correction_applied': [],\n            'measurement_timestamps': []\n        }\n\n        # Student performance metrics\n        self.performance_metrics = {\n            'attitude_stability_score': 0.0,\n            'correction_effectiveness': 0.0,\n            'balance_uptime_seconds': 0.0,\n            'measurements_validated': 0,\n            'achievement_certified': False\n        }\n\n        self.get_logger().info(\"\ud83e\udded Attitude Compensation Controller: Systematic Measurement\")\n        self.get_logger().info(\"Roll/pitch correction maintaining navigation during humanoid locomotion\")\n\n    def calculate_attitude_from_imu(self, torso_imu: Imu, base_imu: Imu) -> AttitudeMeasurement:\n        \"\"\"\n        EDUCATIONAL ALGORITHM: Calculate attitude with gravity compensation\n        Integrates dual IMU data for accurate attitude with walking compensation\n\n        Learning target: Correct navigation direction despite \xb18\xb0 pitch during walking\n        \"\"\"\n\n        # Extract quaternion orientations\n        torso_q = torso_imu.orientation\n        base_q = base_imu.orientation\n\n        # Convert to rotation matrices\n        torso_rotation = Rotation.from_quat([\n            torso_q.x, torso_q.y, torso_q.z, torso_q.w\n        ])\n        base_rotation = Rotation.from_quat([\n            base_q.x, base_q.y, base_q.z, base_q.w\n        ])\n\n        # Calculate attitude angles (Euler angles)\n        torso_euler = torso_rotation.as_euler('xyz', degrees=True)\n        base_euler = base_rotation.as_euler('xyz', degrees=True)\n\n        # Apply fusion for walking movement compensation\n        # Higher weight to base IMU for ground reference during walking\n        comp_weight = 0.7 if self.is_walking_active() else 0.5\n\n        roll_deg = torso_euler[0] * (1 - comp_weight) + base_euler[0] * comp_weight\n        pitch_deg = torso_euler[1] * (1 - comp_weight) + base_euler[1] * comp_weight\n        yaw_deg = torso_euler[2] * comp_weight + base_euler[2] * (1 - comp_weight)\n\n        # Angular velocity compensation\n        torso_vel = torso_imu.angular_velocity\n        base_vel = base_imu.angular_velocity\n\n        roll_vel = (torso_vel.x + base_vel.x) / 2.0\n        pitch_vel = (torso_vel.y + base_vel.y) / 2.0\n        yaw_vel = (torso_vel.z + base_vel.z) / 2.0\n\n        # Calculate gravity vector for balance analysis\n        gravity_vector = self.calculate_compensated_gravity(torso_rotation, base_rotation)\n\n        # Calculate navigation corrections\n        heading_correction = self.calculate_heading_correction(pitch_deg, roll_deg)\n        velocity_correction = self.calculate_velocity_correction(torso_vel, base_vel)\n        position_correction = self.calculate_position_correction(gravity_vector)\n\n        return AttitudeMeasurement(\n            roll_deg=roll_deg,\n            pitch_deg=pitch_deg,\n            yaw_deg=yaw_deg,\n            roll_vel_deg=np.degrees(roll_vel),\n            pitch_vel_deg=np.degrees(pitch_vel),\n            yaw_vel_deg=np.degrees(yaw_vel),\n            gravity_vector=gravity_vector,\n            heading_correction_rad=heading_correction,\n            velocity_correction_mps=velocity_correction,\n            position_corrector_meters=position_correction,\n            balance_stable=self.assess_balance_stability(torso_imu, base_imu),\n            compensation_active=True,\n            timestamp=time.time()\n        )\n\n    def assess_balance_stability(self, torso_imu: Imu, base_imu: Imu) -> bool:\n        \"\"\"\n        Critical balance preparation before navigation correction\n        Determines if attitude corrections are safe.\n        \"\"\"\n\n        # Extract raw accelerations\n        torso_acc = np.array([torso_imu.linear_acceleration.x,\n                            torso_imu.linear_acceleration.y,\n                          torso_imu.linear_acceleration.z])\n        base_acc = np.array([base_imu.linear_acceleration.x,\n                           base_imu.linear_acceleration.y,\n                          base_imu.linear_acceleration.z])\n\n        # Quick stability assessment\n        # Check if robot is falling (not walking normally)\n        gravity_check = np.abs(torso_acc[2] - base_acc[2])  # Vertical acceleration difference\n        horizontal_rms = np.sqrt(torso_acc[0]**2 + torso_acc[1]**2)\n\n        # Determine balance status based on acceleration patterns\n        # Falling: Large vertical difference and extreme horizontal components\n        balance_stable = (gravity_check < 0.5 * 9.81) and (horizontal_rms < 2.0)\n\n        return balance_stable\n\n    def calculate_heading_correction(self, pitch_deg: float, roll_deg: float) -> float:\n        \"\"\"\n        Compute navigation heading correction due to attitude changes\n        Pitch affects forward component, roll affects lateral component\n        \"\"\"\n\n        # Convert to radians\n        pitch_rad = np.radians(pitch_deg)\n  roll_rad = np.radians(roll_deg)\n\n        # Navigation direction is combination of attitude correctors\n        heading_correction_yaw = np.arctan2(\n      np.sin(roll_rad),  # Lateral vs forward priority\n            np.cos(pitch_rad)\n        )\n\n        # Apply correction limitation to prevent navigation instability'\n        max_correction = self.balance_constraints['heading_correction_limit']\n        return np.clip(heading_correction_yaw, -max_correction, max_correction)\n\n    def calculate_velocity_correction(self, torso_vel: Vector3, base_vel: Vector3) -> float:\n  \"\"\"\n        Apply counter velocity when attitude affects platform velocity\n        Prevents navigation drift during torso sway\n        \"\"\"\n\n        # Calculate required compensation to maintain platform velocity\n        # During standing still, this compensates for torso sway\n        compensation_x = 0.02 * (base_vel.z - torso_vel.z)  # Forward component\n        compensation_y = 0.01 * (base_vel.x - torso_vel.x)  # Lateral component\n\n        # Combine into velocity magnitude\n        total_compensation = np.sqrt(compensation_x**2 + compensation_y**2)\n\n       # Limit compensation to prevent navigation oscillation\n        max_correction = self.balance_constraints['velocity_correction_limit']\n        return np.clip(total_compensation, -max_correction, max_correction)</reasoning>continue\n"})})]})}function m(n={}){const{wrapper:t}={...(0,i.R)(),...n.components};return t?(0,o.jsx)(t,{...n,children:(0,o.jsx)(_,{...n})}):_(n)}},8453:(n,t,e)=>{e.d(t,{R:()=>r,x:()=>c});var a=e(6540);const o={},i=a.createContext(o);function r(n){const t=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function c(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),a.createElement(i.Provider,{value:t},n.children)}}}]);