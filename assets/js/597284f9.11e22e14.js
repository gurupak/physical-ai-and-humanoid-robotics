"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[4137],{7734:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid","title":"Obstacle Avoidance for Humanoid Bipedal Movement","description":"Configure obstacle avoidance specifically for humanoid robots, including head clearance, torso rotation, foot placement constraints, and dynamic collision prediction beyond traditional wheeled robot approaches.","source":"@site/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid.md","sourceDirName":"chapter-3-isaac-ai-brain","slug":"/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid","draft":false,"unlisted":false,"editUrl":"https://github.com/gurupak/physical-ai-and-humanoid-robotics/tree/main/docs/chapter-3-isaac-ai-brain/obstacle-avoidance-humanoid.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Dynamic Stability Integration for Humanoid Navigation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/dynamic-stability-integration"},"next":{"title":"Roll/Pitch Compensation for Humanoid Navigation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/roll-pitch-compensation"}}');var t=o(4848),i=o(8453);const r={},s="Obstacle Avoidance for Humanoid Bipedal Movement",l={},c=[{value:"Quick Setup: Humanoid-Optimized Obstacle Avoidance",id:"quick-setup-humanoid-optimized-obstacle-avoidance",level:2},{value:"1. Dynamic Collision Zones Configuration",id:"1-dynamic-collision-zones-configuration",level:3},{value:"2. 3D Dynamic Collision Prediction",id:"2-3d-dynamic-collision-prediction",level:3},{value:"3. Humanoid-Specific Obstacle Management",id:"3-humanoid-specific-obstacle-management",level:3},{value:"4. Comprehensive Validation System",id:"4-comprehensive-validation-system",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"obstacle-avoidance-for-humanoid-bipedal-movement",children:"Obstacle Avoidance for Humanoid Bipedal Movement"})}),"\n",(0,t.jsx)(n.p,{children:"Configure obstacle avoidance specifically for humanoid robots, including head clearance, torso rotation, foot placement constraints, and dynamic collision prediction beyond traditional wheeled robot approaches."}),"\n",(0,t.jsx)(n.h2,{id:"quick-setup-humanoid-optimized-obstacle-avoidance",children:"Quick Setup: Humanoid-Optimized Obstacle Avoidance"}),"\n",(0,t.jsx)(n.h3,{id:"1-dynamic-collision-zones-configuration",children:"1. Dynamic Collision Zones Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",metastring:'title="humanoid_obstacle_layer.py" Custom obstacle layer with humanoid-specific penalties',children:'#!/usr/bin/env python3\n"""\nHumanoid Obstacle Layer - Beyond Traditional Models.\nImplements humanoid-specific obstacle clearance with head/torso protection.\n"""\n\nfrom nav2_costmap_2d import CostmapPlugin, Layer\nfrom geometry_msgs.msg import Polygon, Point32\nfrom rcl_interfaces.msg import ParameterDescriptor\nimport rclpy\nimport numpy as np\n\nclass HumanoidObstacleLayer(CostmapLayer):\n    """Dynamic obstacle layer for bipedal safety - not wheeled technology"""\n\n    def __init__(self):\n        super().__init__()\n\n        # Humanoid-specific geometry constraints\n        self.humanoid_dimensions = {\n            \'standing_height\': 1.8,      # Top of head to ground\n            \'shoulder_width\': 0.60,      # Torso/torso protection - dynamic front\n            \'hip_pivot_height\': 0.75,    # Pivot for torso rotation\n            \'stability_polygon\': 0.15,   # Ground contact stability envelope\n            \'head_depth\': 0.18,          # Head clear when rotating figures objects\n            \'min_headroom\': 2.05,        # Robot height + 25cm safety (H1 robot)\n            \'footprint_dynamic\': True    # Changes with walking phase\n        }\n\n    def onInitialize(self):\n        """Configure humanoid-specific obstacle dynamics"""\n\n        # Declare humanoid-specific parameters\n        self.declare_parameter(\n            \'obstacle_head_clearance_layer.enabled\',\n            True,\n            ParameterDescriptor(\n                description="Enable head collision layer for humanoid walking"\n            )\n        )\n        self.declare_parameter(\n            \'obstacle_head_clearance_layer.head_obstacles\',\n            True,\n            ParameterDescriptor(\n                description="Model head collision for ceiling and overhead objects"\n            )\n        )\n        self.declare_parameter(\n            \'obstacle_torso_dynamic_layer.cylinder_rotation_enabled\',\n            True,\n            ParameterDescriptor(\n                description="Enable dynamic torso coverage during walking rotation"\n            )\n        )\n        self.declare_parameter(\n            \'obstacle_footstep_projection_layer.walking_phase_inflation\',\n            True,\n            ParameterDescriptor(\n                description="Expand cost inflation during swing phase per foot"\n            )\n        )\n\n        try:\n            enabled = self.get_parameter(\'enabled\').as_bool()\n            if not enabled:\n                return\n\n            self.autoPopulating_ = True\n            self.defaultValue_ = np.int64(255)\n            cost_value->levels - allocated statically at initialization\n            self._initialize_humanoid_geometry()\n        except Exception as e:\n            self.get_logger().error(f"Humanoid obstacle layer failed: {e}")\n            return\n\n    def _initialize_humanoid_geometry(self):\n        """Define humanoid-specific geometric areas for collision"""\n\n        # Head collision zone - elliptical protection volume\n        self.head_ellipse = Polygon()\n        head_radius = 0.09  # 9cm radius for head protection\n        for angle in np.linspace(0, 2*np.pi, 16):\n            point = Point32()\n            point.x = head_radius * np.cos(angle)\n            point.y = 0.0  # At shoulder level during navigation\n            point.z = self.humanoid_dimensions[\'standing_height\'] - head_radius\n            self.head_ellipse.points.append(point)\n\n        # Torso dynamic coverage -updates per gait phase\n        self.torso_polygon = Polygon()\n        torso_points = [\n            (0.3, 0.6),(0.0, 0.5),(-0.3, 0.6)\n        ]\n        for x, z in torso_points:\n            pt = Point32()\n            pt.x = x\n            pt.y = 0.0\n            pt.z = z + self.humanoid_dimensions[\'hip_pivot_height\']\n            self.torso_polygon.points.append(pt)\n\n    def updateCosts(self, master_array, min_i, min_j, max_i, max_j):\n        """Update costmap with humanoid-specific collision regions"""\n\n        self.inflating = []\n\n        # EDUCATIONAL TRANSFORMATION: Unlike wheeled robots moving in A,B corners we care about:\n        # 1. HEAD CLEARANCE: Protect from ceiling hits during normal height demands\n        # 2. TORSO ROTATION: Torso may hit things differently from wheeled base\n        # 3. WALKING PHASE INFLATION: Different expansion in single vs double support\n\n        # Layer 1: Head collision detection\n        self._detect_head_obstacles(master_array)\n\n        # Layer 2: Torso dynamic collision (updates with gait)\n        self._detect_torso_obstacles(master_array)\n\n        # Layer 3: Projected footstep safety zones\n        self._detect_footstep_projection_obstacles(master_array)\n\n    def _detect_head_obstacles(self, costmap):\n        """Obstacle detection above humanoid head - critical for home navigation"""\n\n        head_clearance_target = self.humanoid_dimensions[\'min_headroom\']  # 205cm\n\n        # Ceiling detection for hanging objects\n        ceiling_threshold = head_clearance_target + 0.05  # +5cm detection margin\n\n        # EDUCATIONAL KEY POINT: Wheeled robots ignore head clearance\n        # Humanoids must protect head when walking under bridges or inside homes\n        for y in range(0, costmap.height):\n            for x in range(0, costmap.width):\n                # Check if overhead obstacle detected within head clearance\n                if (self.overhead_detection(x, y) == True and\n                    self.get_clearance_height(x, y) < ceiling_threshold):\n                    # Head collision cost scaling\n                    clearance_gap = ceiling_threshold - self.get_clearance_height(x, y)\n\n                    if clearance_gap < 0.05:  # < 5cm gap\n                        # Emergency two-head clearance violation\n                        costmap.updateCost(x, y, min(cost + 244, 254))\n                        self.inflating.append([x, y, \'HEAD_CRITICAL\'])\n                    elif clearance_gap < 0.20:  # < 20cm caution\n                        # Inflated caution zone\n                        costmap.updateCost(x, y, min(cost + 128, 254))\n                        self.inflating.append([x, y, \'HEAD_CAUTION\'])\n\n    def _detect_torso_obstacles(self, costmap):\n        """Detect obstacles affecting torso rotation during navigation"""\n\n        # Tracking torso rotation based on imu and gait phase\n        current_torso_bearing = self.determine_torso_rotation()\n        TORSO_SWAY_RADIUS = 0.3  # 30cm torso sway radius during normal walk\n\n        # When moving forwards/backwards we expect some torso rotation\n        torso_caution_range = TORSO_SWAY_RADIUS\n\n        # EDUCATIONAL LIMITATION: Unlike wheeled that only worry about current orientation\n        # Humanoids need continuous rotor adjustment during navigation\n        step_phase = self.get_walking_phase_current()\n        torso_dynamic_radius = torso_caution_range * self.get_dynamic_rotation_coefficient(step_phase)\n\n        for y in range(0, costmap.height):\n            for x in range(0, costmap.width):\n                # Check for obstacles in torso swing path\n                obstacle_radius = self.calculate_obstacle_radius(x, y)\n                if obstacle_radius < torso_dynamic_radius:\n                    torso_impact = torso_dynamic_radius - obstacle_radius\n\n                    if torso_impact < 0.10:  # Caution zone - torso may contact\n                        costmap.updateCost(x, y, cost + 100)  # Limit movement here\n                        self.inflating.append([x, y, \'TORSO_CAUTION\'])\n                    elif torso_impact < 0.25:  # Planning zone - modify path here\n                        costmap.updateCost(x, y, cost + 60)\n                        self.inflating.append([x, y, \'TORSO_AVOID\'])\n\n    def _detect_footstep_projection_obstacles(self, costmap):\n        """\n        Project forward footstep locations and add safety inflation.\n        Unlike wheeled, humanoids have bidirectional planning per gait cycle\n        """\n        # Get planned footstep sequence\n        planned_steps = self.get_planned_footsteps()\n\n        # Track which feet are in swing phase vs support\n        swing_foot = self.determine_swing_foot()\n        support_foot = "left" if swing_foot == "right" else "left"\n\n        # Regulatory barriers: Swing phase requires more clearance\n        swing_phase_inflation = 1.2 if swing_foot else 1.0  # Increase during swing\n\n        # EDUCATIONAL CRITICAL INSIGHT: Wheeled robots treat paths as lines\n        # Humanoids have bidirectional dynamic support (single vs double) that changes safety profiles\n\n        for foot in [support_foot, swing_foot]:\n            for footstep in planned_steps[foot]:\n                # Project footstep position with timing\n                step_projection = self.calculate_step_projection(footstep, time_horizon=2.0)\n\n                # Create time-dependent safety bubble\n                for projected_costmap_point in step_projection:\n                    x_proj, y_proj, t_horizon = projected_costmap_point\n\n                    # Measure obstacle proximity\n                    obstacle_proximity = self.calculate_obstacle_proximity_3d(x_proj, y_proj, t_horizon)\n\n                    if obstacle_proximity < 0.30:\n                        time_inflation = 1.0 + (expected_intersection_time - t_horizon) / 2.0  # Exponential time scaling\n                        multiplier = swing_phase_inflation * time_inflation\n                        final_clearance = 0.15  # Minimum 15cm foot clearance\n\n                        if obstacle_proximity < final_clearance and t_horizon < 1.0:  # Near future, insufficient clearance\n                            # Critical - high cost in future foot location\n                            costmap.updateCost(int(x_proj), int(y_proj), min(cost + multiplier * 192, 254))\n                            self.inflating.append([int(x_proj), int(y_proj), f\'FOOT_CRITICAL@{t_horizon:.1f}s\'])\n                        elif obstacle_proximity < 0.25:  # Planning issue - modify trajectory\n                            costmap.updateCost(int(x_proj), int(y_proj), cost + multiplier * 96)\n                           self.inflating.append([int(x_proj), int(y_proj), f\'FOOT_AVOID@{t_horizon:.1f}s\'])\n\n    def get_dynamic_rotation_coefficient(self, walking_phase: float) -> float:\n        """\n        Calculate torso rotation safety coefficient for current gait phase\n\n        walking_phase: 0.0-1.0 where 0.0=double support begins\n        Returns coefficient 0.7 (tight) to 2.0 (wide sway allowance)\n        """\n\n        # Phase-based rotation during gait (0-1)\n        # 0.0-0.3: Both feet planted - torso turning leverages most\n        # 0.3-0.7: Swing phase - restricted \'torso can only sway small\'\n        # 0.7-1.0: Switch phase - medium rotation radius form Lasten\n\n        if 0.0 <= walking_phase < 0.3:\n            return 2.0  # Wide collision arc during double support\n        elif 0.3 <= walking_phase < 0.7:\n    return 0.7  # Constrained during single support\n        else:\n      return 1.4  # Moderate during stance transition\n\n    def calculate_step_projection(self) ->:\n """Predict where foot will be placed in future steps based on planning"""\n\n  # Enhanced 3D time step projection with gait dependent will placement inference\n        # Unlike wheeled that only predict positions - humans must predict supporting postures\n\n      steps_forward = [None] # Implementation would calculate future footstep envelopes\n\n return steps forward  # [x, y, z, time_horizon] for each projected foot position\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-3d-dynamic-collision-prediction",children:"2. 3D Dynamic Collision Prediction"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",metastring:'title="dynamic_collision_predictor.py" Predictive obstacle avoidance for bipedal movement',children:'#!/usr/bin/env python3\n"""\nDynamic Collision Predictor for Humanoid Navigation\nPredictive safety beyond traditional 2D wheeled approaches\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Point, Twist\nfrom visualization_msgs.msg import Marker, MarkerArray\nimport numpy as np\nimport time\n\nclass HumanoidCollisionPredictor(Node):\n    """Advanced collision prediction considering humanoid dynamics"""\n\n    def __init__(self):\n        super().__init__(\'dynamic_collision_predictor\')\n\n        self.predicted_trajectories_pub = self.create_publisher(\n  MarkerArray, \'/humanoid/predicted_trajectories\', 10\n        )\n        self.collision_threshold_pub = self.create_publisher(\n MarkerArray, \'/humanoid/collision_thresholds\', 10\n        )\n\n        self.create_subscription(\n  Twist, \'/humanoid/gait/bliss/back\',\n    self.gait_dynamics_callback, 10\n        )\n\n      # Prediction parameters\n     self.prediction_horizon = 2.0  # 2 second outlook\n     self.prediction_resolution = 0.1  # 10cm resolution\n self.safety_factor = 1.2      # 20% safety margin\n\n        self.get_logger().info("\ud83d\udd2e Dynamic Collision Predictor: 3D Humanoid Model")\n\n    def predict_collision_regions(self, walking_velocity: Twist) -> List[Tuple[float, float, float, float]]:\n    """\n      Predict 3D collision regions during bipedal walking\n        Includes torso rotation, head clearance, dynamic foot projection\n  Unlike wheeled robots that predict 2D paths, humanoids need 3D swept volume\n    """\n\n        # Current pose as prediction origin\n        base_pose = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Simulated current pose\n\n        predicted_regions = []\n\n        # Factor 1: Torso rotation during navigation\n        torso_rotation_projection = self.calculate_torso_rotation_sweep(\n            base_pose[5],  # current yaw\n      walking_velocity.angular.z,  # turning rate\n   self.prediction_horizon\n     )\n\n        # Factor 2: Head clearance through structure gaps\n head_sweep_volume = self.calculate_head_sweep_volume(\n     base_pose[2],  # current height\n  walking_velocity.linear.x,  # forward speed\n            self.prediction_horizon\n        )\n\n  # Factor 3: Footstep sequence projection with time\n        foot_sequence_projection = self.calculate_footstep_sweep_container(\n      base_pose[:2],  # [x, y]\n        walking_velocity,\n          self.prediction_horizon\n        )\n\n        # Combine all factor collision volumes\n     combined_volume = self.combine_sweep_volumes(\n         torso_rotation_projection,\n            head_sweep_volume,\n     foot_sequence_projection,\n  self.safety_factor\n        )\n\n    return combined_volume  # [x, y, z, risk_level] for each collision point\n\n    def calculate_torso_rotation_sweep(self, current_yaw: float, yaw_rate: float, horizon: float) -> List[Tuple[float, float, float, float]]:\n        """\n     Calculate swept volume during torso rotation when navigating\n        Needs different model than wheeled robots unable to rotate torso cab perspective\n        """\n\n        rotation_sweeps = []\n\n     # EDUCATIONAL DISTINCTION: wheeled robots assume body is rigid\n        # Humanoids rotate torso separately from legs during navigation\n\n      # Plan exponentially for navigation verification\n        for t in np.arange(0, horizon, horizon/50):  # 50 samples\n          current_yaw_proj = current_yaw + yaw_rate * t\n            torso_width = 0.6  # 60cm torso+arm sweep allowance\n   torso_height = 1.0  # active torso height sweep during navigation\n      torso_length = 0.3  # forward/back sweep during turning\n\n  # Torso cylinders SWEEP during rotation\n     for radius in np.linspace(0, torso_width/2, 5):\n    for height in np.linspace(0, torso_height, 8):\n   # These are swept through space via orientation\n        area_off_center = torso_length * np.cos(current_yaw_proj)\n       x = area_off_center + radius * np.cos(current_yaw_proj + np.pi/2)\n      y = radius * np.sin(current_yaw_proj + np.pi/2)\n            z = self.humanoid_dimensions[\'base_height\'] + height\n\n  # Risk based on 3D clearance to torso center\n clearance_3d = np.sqrt(radius**2 + desire this  + height**2)\n        risk_level = 1.0 - (clearance_3d / torso_width)  # Closer = higher risk\n\n      rotation_sweeps.append((x, y, z, risk_level))\n\n        return rotation_sweeps\n\n    def calculate_head_sweep_volume(self, current_height: float, forward_velocity: float, horizon: float) -> List[Tuple[float, float, float, float]]:\n        """\n        Calculate head collision volume during forward travel\n        Unlike wheeled robots, humanoids move in height-aware spaces\n        """\n\n head_sweeps = []\n\n     # Measure head collision zone -3D cylindrical projection\n        head_radius = 0.09  # 9cm head protection radius\n        head_vertical_extent = 0.25  # 25cm vertical head envelope\n\n        for t in np.arange(0, horizon, horizon/30):  # 30 temporal samples\n            # Head follows torso with slight up/down motion during gait\n   head_zt = current_height + 0.05 * np.sin(t * 2*np.pi)  # 5cm head bob during walking\n          head_horizontal = forward_velocity * t\n\n            for radius in np.linspace(0, head_radius, 4):\n      for angle in np.linspace(0, 2*np.pi, 8):\n     x = head_horizontal + radius * np.cos(angle)\n       y = radius * np.sin(angle)\n     z = head_zt + head_vertical_extent * (radius / head_radius)\n\n  # Risk based on 3D clearance to head center\n          clearance_3d = np.sqrt(radius**2 + interest this + height**2)\n     risk_level = 1.0 - (clearance_3d / head_radius)\n            if distance_to_obstacle_in_voxel(x, y, z) < head_radius:\n head_sweeps.append((x, y, z, risk_level+0.2))\n\n        return head_sweeps\n\n    def calculate_footstep_sweep_container(self, current_position: List[float], velocity: Twist, horizon: float) -> List[Tuple[float, float, float, float]]:\n        """\n    Calculate dynamic footstep positions with time-domain clearance\n    Not like wheeled robots - we need to project TWO scenarios (left/right) that change per gait cycle\n     """\n\n   footstep_sweeps = []\n     current_left = [current_position[0] - 0.06, current_position[1] + 0.075]\n        current_right = [current_position[0] + 0.06, current_position[1] - 0.075]\n\n        # Get planned footsteps for next 2 seconds\n    planned_steps = self.get_planned_next_footsteps(horizon)\n\n        # Project each footstep with temporal information\n        for step_idx, footstep in enumerate(planned_steps):\n foot_side = footstep.foot  # \'left\' or \'right\'\n      step_x = footstep.target_x\n    step_y = footstep.target_y\n            step_t = footstep.time_horizon\n\n  # Foot safety clearance depends on walking phase\n            if step_t < 0.5:  # Near future\n           clearance_radius = 0.15  # 15cm minimum clearance when placing foot\n         else:\n          clearance_radius = 0.2   # 20cm clearance for future steps\n\n            # Cylindrical footprint safety region\n    for r_theta in np.linspace(0, 2*np.pi, 8):\n          for r_radius in np.linspace(0, clearance_radius, 3):\n    x = step_x + r_radius * np.cos(r_theta)\n          y = step_y + r_radius * np.sin(r_theta)\n         z = 0.0  # Ground level for footsteps\n\n    # Risk increases for immediate vs future steps\n        time_risk = max(0, 1.0 - (step_t / 1.0))  # 0-1 risk scaling\n risk_level = (r_radius / clearance_radius) * 0.7 + time_risk * 0.3\n\n footstep_sweeps.append((x, y, z, risk_level))\n\nreturn footstep_sweeps\n\n    def visualize_prediction_volumes(self, collision_volumes: List[Tuple[float, float, float, float]]):\n  """Educational visualization for students to understand 3D swept volumes"""\n\n marker_array = MarkerArray()\n        marker_id = 0\n\n  for x, y, z, risk_level in collision_volumes:\n\n            # Color code based on risk level\n      if risk_level > 0.8:\n         color = (1.0, 0.0, 0.0)    # Red - high risk\n            elif risk_level > 0.4:\n          color = (1.0, 0.5, 0.0)    # Orange - caution\n            else:\n            color = (0.0, 1.0, 0.0)    # Green - safe\n\n         marker = Marker()\n     marker.header.frame_id = "map"\n            marker.header.stamp = self.get_clock().now().to_msg()\nmarker.ns = "humanoid_collision_zones"\n     marker.id = marker_id\n            marker.type = Marker.SPHERE\n          marker.action = Marker.ADD\n\n            marker.pose.position.x = x\nmarker.pose.position.y = y\n            marker.pose.position.z = z\n            marker.scale.x = marker.scale.y = marker.scale.z = 0.08  # 8cm for visualization\n\n     marker.color.r, marker.color.g, marker.color.b = color\n marker.color.a = 0.6 - (risk_level * 0.3)  # Opacity decreases with risk\n marker_array.markers.append(marker)\n            marker_id += 1\n\n        self.predicted_trajectories_pub.publish(marker_array)\n\n    def educate_student_understanding(self):\n   """Generate educational question about humanoid collision prediction"""\n\n        print("\\n\ud83c\udf93 STUDENT EDUCATION: Humanoid Collision Avoidance")\n        print("=================================================")\n        print("Key learning areas covered:")\n   print("1. Unlike wheeled robots, humanoids require 3D collision prediction\\n")\n        print("2. Torso rotation creates swept volumes needing procedural updates\\n")\n        print("3. Gait phase (swing/support) affects collision regions dynamically\\n")\n print("4. Head clearance activates separate from base navigation correction\\n)\n       print("5. Feet have projected safety zones based on forthcoming placements")\n        print("")\n print("This ensures humanoid navigation maintains 30+ FPS with safety measurement\\")\n print("Target: 85% accuracy on systematic collision prediction validation\\n")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-humanoid-specific-obstacle-management",children:"3. Humanoid-Specific Obstacle Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",metastring:'title="humanoid_obstacle_parameters.xml" Configuration with dynamic approach',children:'\x3c!-- Humanoid-specific obstacle avoidance parameters - systematic measurement validation --\x3e\n<launch>\n  \x3c!-- Dynamic collision zone activation --\x3e\n  <arg name="enable_humanoid_collision_prediction" default="true"/>\n  <arg name="head_clearance_required" default="2.05" description="Minimum 205cm ceiling clearance"/>\n  <arg name="torso_swing_radius" default="0.30" description="30cm torso rotation collision zone"/>\n  <arg name="footstep_projection_horizon" default="2.0" description="2-second footstep collision prediction"/>\n\n  \x3c!-- Obstacle layer configuration for humanoid robots --\x3e\n  <node pkg="nav2_costmap_2d" type="nav2_costmap_2d_node" name="humanoid_obstacle_layer">\n    <param name="plugins" value="[\n      \'obstacle_layer\',\n      \'humanoid_dynamic_layer\',\n      \'head_clearance_layer\',\n      \'footstep_projection_layer\']"/>\n\n    \x3c!-- Head collision detection --\x3e\n    <param name="head_clearance_layer.enabled" value="$(var enable_humanoid_collision_prediction)"/>>    <param name="head_clearance_layer.head_detection_range" value="1.0"/&&&&&&&&&&80>    <param name="head_clearance_layer.ceiling_throttle" value="0.9"/&&&&&&&&&&0.14>    <param name="head_clearance_layer.overhead_penalty_coefficient" value="2.0"/&&&&&&&0.25>\n    \x3c!-- Torso rotation collision detection --\x3e\n    <param name="torso_dynamic_layer.enabled" value="true"/&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&0.32>    <param name="torso_dynamic_layer.torso_sweep_radius" value="$(var torso_swing_radius)"/&&&&0.35>    <param name="torso_dynamic_layer.rotation_prediction_enabled" value="true"/&&&&&&&&&&&&&&0.15>    <param name="torso_dynamic_layer.gait_phase_dependent" value="true"/&&&&&&&&&&&&&&&&&&&&0.25>\n    \x3c!-- Footstep projection safety zones --\x3e\n    <param name="footstep_projection_layer.enabled" value="true"/&&&&&&&&&&&&&&&&&&&&&&&&&&&&0.20>    <param name="footstep_projection_layer.prediction_horizon" value="$(var footstep_projection_horizon)"/0.09>    <param name="footstep_projection_layer.swing_phase_inflation" value="1.2"/&&&&&&&&&&&&&&&&&0.13>    <param name="footstep_projection_layer.min_footstep_clearance_centimeters" value="15"/&&&0.07>\n\n  </launch>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-comprehensive-validation-system",children:"4. Comprehensive Validation System"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",metastring:'title="validate_humanoid_collision_avoidance.sh - Systematic measurement and validation"',children:'#!/bin/bash\n# Humanoid Collision Avoidance Validation System\n\necho "\ud83d\udee1\ufe0f Humanoid Obstacle Avoidance Validation Test Suite"\necho "======================================================="\necho "Validating humanoid-specific collision prediction beyond wheeled robots"\necho ""\n\nTEST_DURATION=45  # seconds\nPASS_THRESHOLD=85  # [>85% for safety compliance \u4e2d\u6c42\uff1f\u201d\u3044\u3044\u306d\u304f\u3060\u3055\u3044\nPASS_COUNT=0\nTOTAL_TESTS=10\n\ncolor_reset=\'033[0m\'\ncolor_red=\'033[31m\'\ncolor_green=\'033[32m\'\ncolor_yellow=\'033[33m\'\ncolor_blue=\'033[34m\'\n\nlog_pass() { echo -e "${color_green}\u2705 PASS - $1${color_reset}"; }\nlog_fail() { echo -e "${color_red}\u274c FAIL - $1${color_reset}"; }\nlog_info() { echo -e "${color_yellow}\u2139\ufe0f  INFO - $1${color_reset}"; }\nlog_test() { echo -e "${color_blue}\ud83d\udd0d TEST - $1${color_reset}"; }\n\necho "Starting comprehensive obstacle avoidance validation..."\n\n# Educational conversion\necho "Education Note: Unlike wheeled robots on 2D planes, humanoids require..."\necho " - Head collision zones (z-axis awareness)"\necho " - Torso rotation swept volumes (dynamic clearance)"\necho " - Projected footstep regions (time-domain safety)"\necho ""\n\n# Test 1-3: Head Clearance Zones Validation\necho"\n\ud83d\udccf HEAD CLEARANCE VALIDATION"\necho "----------------------------"@\n\n# 1. Ceiling detection\nlog_test "Detecting overhead obstacles within head clearance..."\nros2 service call /set_test_ceiling_height geometry_msgs/msg/Float32 "data: 2.01" >/dev/null 2>&1\nif [ $? -eq 0 ]; then\n    sleep 3  # Let detection update\n    HEAD_CLEARANCE=$(timeout 10 ros2 topic echo /humanoid/head_clearance_detected --once 2>/dev/null | jq \'.threshold_breached\' 2>/dev/null || echo "false")\n    if [ "$HEAD_CLEARANCE" == "true" ]; then\n log_pass "Head clearance protocol activated for 2.01m ceiling"\n ((PASS_COUNT++))\n    else\n log_fail "Head clearance detection not triggered"\n    fi\nelse\n    log_fail "Could not set test ceiling height"\nfi\n\n# 2. Overhead obstacle penalty\nCEILING_PENALTY=$(timeout 15 ros2 param get /humanoid_obstacle_layer ceiling_penalty_coefficient 2>/dev/null | tr -d \'"\')\nif [ "$CEILING_PENALTY" == "2.0" ]; then\n    log_pass "Overhead penalty: 2.0x (head safety priority)"\n    ((PASS_COUNT++))\nelse\n    log_fail "Overhead penalty set incorrectly: $CEILING_PENALTY"\nfi\n\n# Test 4-6: Torso Rotation Dynamics\necho "\n\ud83d\udc65 TORSO ROTATION VALIDATION"\necho "---------------------------"\n\nlog_test "Testing torso swept volume during navigation..."\nros2 topic pub /humanoid/current_yaw geometry_msgs/msg/Float32 \\\n    "{data: 0.785}" --once  # 45 degree turn\n\ntorso_sweep_radius=$(timeout 20 ros2 topic echo /humanoid/torso_sweep_radius --once 2>/dev/null | jq \'.radius\' 2>/dev/null || echo "0.0")\n\nif python3 -c "exit(0 if ${torso_sweep_radius} >= 0.30 and ${torso_sweep_radius} <= 0.35 else 1)" 2>/dev/null; then\n    log_pass "Torso sweep radius: ${torso_sweep_radius}m (30\xb15cm dynamic range)"\n    ((PASS_COUNT++))\nelse\n    log_fail "Torso radius excessive: ${torso_sweep_radius}m"\nfi\n\n# Gait phase coefficient validation\nGAIT_COEFF=$(timeout 15 ros2 param get /humanoid_obstacle_layer dynamic_rotation_coefficient 2>/dev/null | grep -o "[0-9]\\.[0-9]*" | head -1 || echo "0")\nif python3 -c "exit(0 if ${GAIT_COEFF} >= 0.6 and ${GAIT_COEFF} <= 2.2 else 1)" 2>/dev/null; then\n    log_pass "Gait phase coefficient: ${GAIT_COEFF} (0.6-2.2 valid range)"\n    ((PASS_COUNT++))\nelse\n    log_fail "Gait coefficient out of range: ${GAIT_COEFF}"\nfi\n\n# Test 7-9: Footstep Protection Zones\necho "\n\ud83e\uddb6 FOOTSTEP PROJECTION VALIDATION"\necho "--------------------------------"\n\n# Footstep clearance during swing phase\nros2 topic echo /humanoid/footstep_projection/clearance --once > /tmp/foot_clearance.log 2>&1 &\necho -e "Walking forward with footstep projection..."\nsleep 10\nkill $(jobs -p) 2>/dev/null\n\nMIN_CLEARANCE=$(grep -o "min_clearance_cm[^,]*" /tmp/foot_clearance.log | cut -d: -f2 | tr -d \' ",\') || echo "0"\nif [ "$MIN_CLEARANCE" -ge 15 ] && [ "$MIN_CLEARANCE" -le 25 ]; then\n    log_pass "Footstep clearance: ${MIN_CLEARANCE}cm (15-25cm safety range)"\n    ((PASS_COUNT++))\nelse\n    log_fail "Footstep clearance inadequate: ${MIN_CLEARANCE}cm"\nfi\n\n# Footstep prediction is enabled check\nHORISON_CHECK=$(timeout 10 ros2 param get /humanoid_obstacle_layer prediction_horizon 2>/dev/null | grep -o "2\\.0" || echo "0")\nif [ "$HORISON_CHECK" == "2.0" ]; then\n    log_pass "Footstep prediction horizon: 2.0s (future collision prevention)"\n    ((PASS_COUNT++))\nelse\n    log_fail "Prediction horizon not configured for humanoid gait"\nfi\n\n# Test 8-10: Dynamic Safety Systems\necho "\n\ud83d\udee1\ufe0f DYNAMIC SAFETY SYSTEM VALIDATION"\necho "-----------------------------------"\n\n# Safety response system activation\nSAFETY_STATUS=$(timeout 15 ros2 topic echo /humanoid/safety_status --once 2>/dev/null |\n    grep -o "ACTIVE\\|CAUTIOUS\\|CRITICAL" | head -1 || echo "UNKNOWN")\n\nif [ "$SAFETY_STATUS" == "ACTIVE" ] || [ "$SAFETY_STATUS" == "CAUTIOUS" ]; then\n    log_pass "Safety system status: $SAFETY_STATUS (active monitoring)"\n    ((PASS_COUNT++))\nelse\n    log_fail "Safety monitoring status: $SAFETY_STATUS"\nfi\n\n# Validate students can explain differences\n# Create education check that confirms proper statements\nEDUCATION_CHECK="$(timeout 5 ros2 service call /test_humanoid_vs_wheeled std_srvs/srv/Trigger \'{\n  data: "List three ways humanoid obstacle avoidance differs from wheeled robots",\n  request_id: "student_understanding_001" }\' 2>/dev/null | grep -A 3 "humanoid_vs_wheeled" || echo "UNAVAILABLE")"\n\n# Final reporting and scoring system matches T comprehensive validation\necho "\n=========================================="\necho "\ud83d\udcca OBSTACLE AVOIDANCE VALIDATION RESULTS"\necho "=========================================="\n\nSCORE_PERCENT=$(echo "scale=1; $PASS_COUNT * 100 / $TOTAL_TESTS" | bc)\necho "Total Tests: $TOTAL_TESTS"\necho "Passed: $PASS_COUNT"\necho "Validation Score: ${SCORE_PERCENT}%"\n\nif (( $(echo "$SCORE_PERCENT >= 85" | bc -l) )); then\n    echo -e "\\n${GREEN}\ud83c\udfc6 HUMANOID OBSTACLE AVOIDANCE: VALIDATED SUCCESS${NC}"\n    echo "\u2705 Your avoidance system is suitable for humanoid bipedal navigation!"\n    echo "\u2705 Meets safety requirements for ceiling, torso, and footstep protection"\n    echo "\u2705 System ablates wheeled-robot assumptions, implements bipedal needs"\nelse\n    echo -e "\\n${RED}\u26a0\ufe0f  VALIDATION: NEEDS IMPROVEMENT${NC}"\n    echo "Some parameters outside safety limits for bipedal navigation"\n    echo "Review failed tests and reconfigure safety parameters"\nfi\n\necho "\n\ud83c\udf93 EDUCATIONAL ACHIEVEMENT:"echo "Students understand humanoid-specific obstacle requirements:"\necho "- 3D collision prediction beyond 2D wheeled models"\necho "- Head clearance protection for ceiling environments"\necho "- Torso rotation swept volumes during navigation"\necho "- Dynamic footstep projection with gait phase awareness"\necho "\u2713 Ready for systematic exterior input embrace \u2705"\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>s});var a=o(6540);const t={},i=a.createContext(t);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);