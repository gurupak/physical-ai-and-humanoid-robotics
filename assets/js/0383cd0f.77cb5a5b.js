"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[6368],{6428:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"chapter-3-isaac-ai-brain/bipedal-path-planning","title":"Bipedal Path Planning Setup for Humanoid Navigation","description":"Configure footstep-based navigation with humanoid-specific constraints including step clearance, head room, torso sway compensation, and systematic walking pattern validation.","source":"@site/docs/chapter-3-isaac-ai-brain/bipedal-path-planning.md","sourceDirName":"chapter-3-isaac-ai-brain","slug":"/chapter-3-isaac-ai-brain/bipedal-path-planning","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/bipedal-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/gurupak/physical-ai-and-humanoid-robotics/tree/main/docs/chapter-3-isaac-ai-brain/bipedal-path-planning.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Nav2 Configuration for Humanoid Bipedal Movement","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/nav2-humanoid-configuration"},"next":{"title":"Footstep Planning Parameters and Validation","permalink":"/physical-ai-and-humanoid-robotics/docs/chapter-3-isaac-ai-brain/footstep-planning-parameters"}}');var a=t(4848),s=t(8453);const i={},o="Bipedal Path Planning Setup for Humanoid Navigation",l={},m=[{value:"Quick Setup: Footstep-Based Planning (5 minutes)",id:"quick-setup-footstep-based-planning-5-minutes",level:2},{value:"1. Essential Footstep Parameters",id:"1-essential-footstep-parameters",level:3},{value:"2. Dynamic Footstep Planning Node",id:"2-dynamic-footstep-planning-node",level:3},{value:"3. Measurement and Validation Tools",id:"3-measurement-and-validation-tools",level:3},{value:"4. Success Criteria and Testing",id:"4-success-criteria-and-testing",level:3},{value:"Educational Success Framework",id:"educational-success-framework",level:2},{value:"For Students: What Each Measurement Means",id:"for-students-what-each-measurement-means",level:3},{value:"Validation Success Criteria",id:"validation-success-criteria",level:3}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"bipedal-path-planning-setup-for-humanoid-navigation",children:"Bipedal Path Planning Setup for Humanoid Navigation"})}),"\n",(0,a.jsx)(n.p,{children:"Configure footstep-based navigation with humanoid-specific constraints including step clearance, head room, torso sway compensation, and systematic walking pattern validation."}),"\n",(0,a.jsx)(n.h2,{id:"quick-setup-footstep-based-planning-5-minutes",children:"Quick Setup: Footstep-Based Planning (5 minutes)"}),"\n",(0,a.jsx)(n.h3,{id:"1-essential-footstep-parameters",children:"1. Essential Footstep Parameters"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",metastring:'title="footstep_navigation_config.yaml" Complete footstep planning parameters for humanoid robots',children:"# Footstep Navigation Configuration for H1 Humanoid\r\n# Systematically measure each parameter for student verification\r\n\r\nhumanoid_footstep_planner:\r\n  ros__parameters:\r\n    # Humanoid robot dimensions (H1 specifications)\r\n    robot_specifications:\r\n      height: 1.8          # meters - safety ceiling requirement\r\n      torso_width: 0.6     # meters - shoulder width for doorway clearance\r\n      foot_length: 0.30    # meters - actual foot length for step planning\r\n      foot_width: 0.15     # meters - foot width for stability\r\n      leg_length: 0.75     # meters - max step length at highest angle\r\n\r\n    # Footstep geometry constraints (SYSTEMATIC MEASUREMENT REQUIRED)\r\n    footstep_constraints:\r\n      ##############################################################\r\n      # STUDENT VERIFICATION: Each parameter has measurement target #\r\n      ##############################################################\r\n\r\n      # STEP 1: Maximum stride length (measure via camera/IMU output once + graph)\r\n      max_step_length: 0.60        # VERIFICATION: \u2265 0.55m found in testing range encountered.validation()\r\n      min_step_length: 0.10        # VERIFICATION: \u2265 0.08m for measured min step\r\n      optimum_step_length: 0.45    # VERIFICATION: Target step = 0.45\xb10.05m for natural walking\r\n\r\n      # STEP 2: Lateral step limits (human hip abduction/adduction limits)\r\n      max_lateral_offset: 0.20     # VERIFICATION: \u2264 0.22m measured abduction limit\r\n      min_lateral_clearance: 0.08  # VERIFICATION: \u2265 0.06m foot-side clearance\r\n\r\n      # STEP 3: Vertical climbing capability (Stair navigation)\r\n      max_step_height_up: 0.18     # VERIFICATION: \u2286 Up to 18cm measured stair climb capability\r\n      max_step_height_down: 0.12   # VERIFICATION: \u2265 11cm down step capability\r\n      step_height_variance: 0.02   # VERIFICATION: \xb12cm for natural gait frequencies\r\n\r\n      # STEP 4: Angular constraints (hip rotation limits)\r\n      max_yaw_per_step: 25.0       # VERIFICATION: 25\xb13\xb0 per step measured allowance\r\n      critical_yaw_threshold: 45.0 # VERIFICATION: \u2265 42\xb0 measured maximum rotation capability\r\n\r\n      # STEP 5: Foot placement precision (measurement accuracy)\r\n      foot_placement_tolerance: 0.03  # VERIFICATION: \xb13cm foot landing accuracy target\r\n      ground_contact_margin: 0.005    # VERIFICATION: 0.5cm ground clearance allowance\r\n\r\n    # Dynamic stability parameters (critical for balance)\r\n    stability_constraints:\r\n      ##################################################################\r\n      # STUDENT MEASUREMENT: Dynamic stability verification required  #\r\n      ##################################################################\r\n\r\n      # Center of Mass (CoM) tracking\r\n      com_projected_area: 0.08     # VERIFICATION: ~80cm\xb2 measured CoM support polygon\r\n      com_margin_multiplier: 1.8   # VERIFICATION: 1.8x safety margin measured\r\n\r\n      # Zero Moment Point (ZMP) constraints\r\n      zmp_x_tolerance: 0.04        # VERIFICATION: \xb140mm ZMP offset - forward/backward\r\n      zmp_y_tolerance: 0.02        # VERIFICATION: \xb120mm ZMP offset - sideways\r\n\r\n      # Static stability (double support phase)\r\n      ds_straight_margin: 0.06     # VERIFICATION: 6cm safety margin in double support\r\n      ds_turn_margin: 0.08         # VERIFICATION: 8cm margin during turning in double support\r\n\r\n      # Dynamic stability (single support phase)\r\n      ss_pitch_velocity_limit: 5.0   # VERIFICATION: \u2264 5\xb0/s measured pitch rotation during walk\r\n      ss_roll_velocity_limit: 7.0    # VERIFICATION: \u2264 7\xb0/s measured roll rotation during walk\r\n\r\n      # Torso sway compensation\r\n      torso_sway_x_limit: 0.03     # VERIFICATION: \xb130mm torso sway in forward direction\r\n      torso_sway_y_limit: 0.02     # VERIFICATION: \xb120mm torso sway in lateral direction\r\n      torso_y_correction_gain: 0.0 # VERIFICATION: No lateral correction (inherent in biped)\r\n\r\n    # Gait cycle parameters (synchronized timing)\r\n    gait_timing:\r\n      ############################################################\r\n      # SYSTEMATIC MEASUREMENT: Gait cycle timing validation     #\r\n      ############################################################\r\n\r\n      # Double support phase (both feet on ground)\r\n      ds_duration: 0.20           # VERIFICATION: 0.2\xb10.1s measured double support time\r\n      ds_velocity_gain: 0.1       # VERIFICATION: Limited to 0.1m/s during transitions\r\n\r\n      # Single support phase (one foot on ground)\r\n      ss_duration: 0.65           # VERIFICATION: 0.6\xb10.1s measured single support time\r\n      ss_velocity_limit: 0.5      # VERIFICATION: \u2264 0.5m/s during single support for stability\r\n\r\n      # Gait cycle frequency\r\n      preferred_gait_frequency: 1.2 # VERIFICATION: 1.2\xb10.3Hz natural walking rhythm\r\n      min_gait_frequency: 0.5       # VERIFICATION: \u2265 0.4Hz minimum sustainable pace\r\n      max_gait_frequency: 2.0       # VERIFICATION: \u2264 2.1Hz maximum fast pacing measured\r\n\r\n    # Environmental clearance constraints\r\n    clearance_constraints:\r\n      ###############################################################\r\n      # MEASUREMENT VALIDATION: Environmental clearance tracking  #\r\n      ###############################################################\r\n\r\n      # Ground clearance (measure with depth sensor while walking)\r\n      foot_ground_clearance: 0.08  # VERIFICATION: 8\xb12cm measured foot swing height\r\n      early_foot_raise: 0.05       # VERIFICATION: 5cm early foot raise for uneven terrain\r\n\r\n      # Step-over clearance\\essional measurement compliment\r\n      max_step_over_height: 0.12   # VERIFICATION: 12\xb13cm measured step over height@ incursions/*here Place: Lineas/*/\r\n      step_over_approach_distance: 0.30 # VERIFICATION: 30cm run-up before obstacles\r\n\r\n      # Head clearance (ceiling awareness)\r\n      min_head_clearance: 2.05     # VERIFICATION: 205cm minimum ceiling for tall humanoid\r\n      head_approach_distance: 0.50 # VERIFICATION: 50cm slow-down near ceiling constraints\r\n\r\n      # Doorway navigation\r\n      min_doorway_width: 0.90      # VERIFICATION: 90cm minimum for H1 humanoid width+sway\r\n      doorway_approach_angle: 5.0   # VERIFICATION: 0-5\xb0 approach angle through doorways\r\n\r\n    # Validation and measurement tracking\r\n    validation_settings:\r\n      ############################################################\r\n      # STUDENT VALIDATION: These parameters enable verification  #\r\n      ############################################################\r\n\r\n      # Enable measurement publishing for student verification\r\n      publish_footstep_rviz: true      # Visualizes candidate footsteps\r\n      publish_stability_metrics: true  # Publishes stability calculations\r\n      publish_measurement_data: true   # Raw measurement data for student analysis\r\n\r\n      # Validation reporting\r\n      expected_performance:\r\n        min_step_distance: 0.4         # Target for student: \u2265 0.4m optimal step\r\n        max_stability_variance: 0.08   # Target: < 8% stability fluctuations\r\n        min_obstacle_clearance: 0.05   # Target: \u2265 5cm clearance maintainedObj\r\n        max_planning_variance: 30      # Target: < 30\xb0 heading variance\r\n\r\n      # Success thresholds for automated testing\r\n      footstep_plan_success_threshold: 0.9   # 90% of plans must valid\r\n      stability_monitor_timeout: 2.0     # 2 second max stability perturbation\r\n      measurement_accuracy_threshold: 0.01 # 1cm measurement resolution requiredObj\r\n\r\n  ##############################################################################\r\n  # Implementation: Movement constraints automatically derive from VERIFICATION #\r\n  # measurements taken during humanoid testing phases                          #\r\n  ##############################################################################\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-dynamic-footstep-planning-node",children:"2. Dynamic Footstep Planning Node"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",metastring:'title="humanoid_footstep_planner.py" Complete footstep planning with systematic measurement validation',children:"#!/usr/bin/env python3\r\n\"\"\"\r\nHumanoid Footstep Path Planner - Educational Implementation\r\nSystematic measurement validation for each footstep parameter\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Pose2D, PoseStamped, PoseArray, Twist\r\nfrom nav_msgs.msg import Path, OccupancyGrid\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\nimport numpy as np\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Tuple, Optional\r\nfrom enum import Enum\r\n\r\nclass FootstepPhase(Enum):\r\n    \"\"\"Humanoid walking phases\"\"\"\r\n    DOUBLE_SUPPORT = 0\r\n    SWING_START = 1\r\n    SWING_TRANSITION = 2\r\n    FOOT_DOWN = 3\r\n    DOUBLE_TRANSFER = 4\r\n\r\n@dataclass\r\nclass Footstep:\r\n    \"\"\"Individual footstep with measurement verification\"\"\"\r\n    foot: str  # 'left' or 'right'\r\n\r\n    position: Tuple[float, float, float]\r\n    orientation: Tuple[float, float, float, float]\r\n\r\n    # MEASUREMENT TRACKING: All positions verified against constraints\r\n    measured_x: float\r\n    measured_y: float\r\n    measured_z: float\r\n    measured_yaw: float\r\n\r\n    # Stability verification parameters\r\n    zmp_x: float\r\n    zmp_y: float\r\n\r\n    # Constraints validation\r\n    step_length: float = 0.0\r\n    lateral_offset: float = 0.0\r\n\r\n    # PERFORMANCE VERIFICATION: Check each parameter against limits\r\n    def validate_constraints(self):\r\n        \"\"\"Validate footstep against measured constraints\"\"\"\r\n        validation_results = {}\r\n\r\n        # Step length verification\r\n        if self.step_length > 0.6:  # max_step_length\r\n            validation_results['step_length'] = 'FAILED - exceeds 60cm limit'\r\n        elif self.step_length < 0.10:  # min_step_length\r\n            validation_results['step_length'] = 'FAILED - below 10cm minimum'\r\n        else:\r\n            validation_results['step_length'] = 'PASSED'\r\n\r\n        # Lateral offset verification\r\n        if abs(self.lateral_offset) > 0.2:  # max_lateral_offset\r\n            validation_results['lateral_offset'] = 'FAILED - exceeds 20cm abduction limit'\r\n        else:\r\n            validation_results['lateral_offset'] = 'PASSED'\r\n\r\n        # ZMP stability verification\r\n        if abs(self.zmp_x) > 0.04:  # zmp_x_tolerance\r\n            validation_results['zmp_stability'] = 'FAILED - X-axis stability exceeded'\r\n        elif abs(self.zmp_y) > 0.02:  # zmp_y_tolerance\r\n            validation_results['zmp_stability'] = 'FAILED - Y-axis stability exceeded'\r\n        else:\r\n            validation_results['zmp_stability'] = 'PASSED'\r\n\r\n        return validation_results\r\n\r\nclass HumanoidFootstepPlanner(Node):\r\n    \"\"\"Systematic footstep planning with measurement validation\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('humanoid_footstep_planner')\r\n\r\n        # Publishers for visualization and measurement\r\n        self.footstep_pub = self.create_publisher(\r\n            PoseArray, '/humanoid/footsteps/planned', 10\r\n        )\r\n        self.validation_pub = self.create_publisher(\r\n            MarkerArray, '/humanoid/footstep_validation', 10\r\n        )\r\n        self.metrics_pub = self.create_publisher(\r\n            Twist, '/humanoid/step_metrics', 10\r\n        )\r\n\r\n        self.get_logger().info(\"Humanoid Footstep Planner: Systematic measurement validation\")\r\n\r\n        # Current footDetails (student coordinates)\r\n        self.current_pose = [0.0, 0.0, 0.0]  # x, y, yaw\r\n        self.current_support_foot = 'right'  # Start on right foot by convention\r\n        self.feet_positions = {'left': [-0.06, 0.075, 0.0], 'right': [-0.06, -0.075, 0.0]}\r\n\r\n    def plan_bipedal_trajectory(self, target_pose: List[float]) -> List[Footstep]:\r\n        \"\"\"\r\n        THIS IS THE STUDENT'S MAIN FUNCTION - Ensure all measurements are validated\r\n        Plan complete footstep trajectory from current pose to target\r\n\r\n        Args:\r\n            target_pose: [x, y, yaw] target pose\r\n\r\n        Returns:\r\n            List of planned footsteps with measurement validation\r\n        \"\"\"\r\n\r\n        self.get_logger().info(f\"Plan request: {target_pose}\")\r\n\r\n        footsteps = []\r\n\r\n        # STUDENT MEASUREMENT PHASES:\r\n\r\n        # PHASE 1: Path segmentation for humanoid walking\r\n        path_segments = self.segment_bipedal_path(self.current_pose, target_pose)\r\n        measurable_steps = self.calculate_measurable_footsteps(path_segments)\r\n\r\n        # PHASE 2: Step sequence generation with geometric constraints\r\n        step_sequence = self.generate_step_sequence(measurable_steps)\r\n        validated_sequence = self.validate_step_constraints(step_sequence)\r\n\r\n        # PHASE 3: Stability analysis and ZMP verification\r\n        for step_index, step_params in enumerate(validated_sequence):\r\n            footstep = self.create_validated_footstep(step_params, step_index)\r\n            stability_check = footstep.validate_constraints()\r\n\r\n            # STUDENT VERIFICATION: Report any validation failures\r\n            if 'FAILED' in str(stability_check):\r\n                self.get_logger().warn(f\"Step {step_index} validation: {stability_check}\")\r\n            else:\r\n                self.get_logger().info(f\"Step {step_index} validation: PASSED\")\r\n\r\n            footsteps.append(footstep)\r\n\r\n        return footsteps\r\n\r\n    def segment_bipedal_path(self, start: List[float], end: List[float]) -> List[List[float]]:\r\n        \"\"\"\r\n        STUDENT MEASUREMENT 1: Segment path into bipedal locomotion segments\r\n        This divides paths into manageable sections considering humanoid constraints\r\n\r\n        Target: Achieve \u2264 0.6m per footstep segment\r\n        Measurement: Visual inspection of path segments during execution\r\n        \"\"\"\r\n\r\n        dx = end[0] - start[0]\r\n        dy = end[1] - start[1]\r\n        dyaw = end[2] - start[2]\r\n\r\n        total_distance = np.sqrt(dx*dx + dy*dy)\r\n\r\n        # Enforce maximum segment length (measured constraint)\r\n        max_segment_length = 0.6  # max_step_length constraint\r\n        num_segments = int(np.ceil(total_distance / max_segment_length))\r\n\r\n        if num_segments < 1:\r\n            num_segments = 1\r\n\r\n        segments = []\r\n\r\n        for i in range(num_segments + 1):\r\n            t = i / num_segments\r\n            segment_pose = [\r\n                start[0] + t * dx,\r\n                start[1] + t * dy,\r\n                start[2] + t * dyaw\r\n            ]\r\n            segments.append(segment_pose)\r\n\r\n        # STUDENT VERIFICATION: Each segment must conform to max_step_length\r\n        for i, segment in enumerate(segments[1:], 1):\r\n            segment_distance = np.sqrt(\r\n                (segment[0] - segments[i-1][0])**2 +\r\n                (segment[1] - segments[i-1][1])**2\r\n            )\r\n            if segment_distance > max_segment_length:\r\n                self.get_logger().error(f\"Segment {i} exceeds max length: {segment_distance:.3f}m\")\r\n                # This would indicate a measurement validation failure\r\n\r\n        self.get_logger().info(f\"Path segmented into {len(segments)} steps (max: 0.6m each)\")\r\n        return segments\r\n\r\n    def calculate_measurable_footsteps(self, segment_poses: List[List[float]]) -> List[dict]:\r\n        \"\"\"STUDENT MEASUREMENT 2: Convert path segments to measurable footstep parameters\"\"\"\r\n\r\n        measurable_steps = []\r\n\r\n        for i in range(len(segment_poses) - 1):\r\n            current = segment_poses[i]\r\n            target = segment_poses[i + 1]\r\n\r\n            # Calculate actual step parameters for measurement\r\n            step_length = np.sqrt((target[0] - current[0])**2 + (target[1] - current[1])**2)\r\n            step_angle = np.arctan2(target[1] - current[1], target[0] - current[0]) - current[2]\r\n\r\n            # Verify these measurements against constraints\r\n            measurement_result = {\r\n                'index': i,\r\n                'start': current,\r\n                'end': target,\r\n                'measured_length': step_length,              # KEY MEASUREMENT 1\r\n                'measured_angle': np.degrees(step_angle),    # KEY MEASUREMENT 2\r\n                'support_foot': self.current_support_foot,\r\n                'constraint_valid': True  # Will be validated later\r\n            }\r\n\r\n            # STUDENT INTERACTION POINT: Real-time measurement feedback\r\n            self.get_logger().info(\r\n                f\"Step {i}: L={step_length:.3f}m, \u0391={np.degrees(step_angle):.1f}\xb0, \"\r\n                f\"{self.current_support_foot} foot\"\r\n            )\r\n\r\n            measurable_steps.append(measurement_result)\r\n\r\n            # Alternating foot support\r\n            self.current_support_foot = 'left' if self.current_support_foot == 'right' else 'right'\r\n\r\n        return measurable_steps\r\n\r\n    def generate_step_sequence(self, measurable_steps: List[dict]) -> List[dict]:\r\n        \"\"\"\r\n        STUDENT IMPLEMENTATION: Generate physical footstep positions\r\n        Convert abstract path segments to actual foot placement coordinates\r\n        \"\"\"\r\n\r\n        step_sequence = []\r\n\r\n        for step in measurable_steps:\r\n            # Calculate actual footstep placement based on geometric constraints\r\n\r\n            # Determine foot position considering baseline\r\n            foot_baseline = 0.12  # 12cm human-like separation\r\n            lateral_offset = foot_baseline / 2\r\n            if step['support_foot'] == 'left':\r\n                lateral_offset *= -1\r\n\r\n            # Apply step geometry\r\n            actual_step = {\r\n                'foot': step['support_foot'],\r\n                'position': [\r\n                    step['end'][0] - lateral_offset * np.sin(np.radians(step['measured_angle'])),\r\n                    step['end'][1] + lateral_offset * np.cos(np.radians(step['measured_angle'])),\r\n                    step['end'][2]\r\n                ],\r\n                'orientation': [0.0, 0.0, 0.0, 1.0],\r\n                'step_length': step['measured_length'],\r\n                'yaw_change': step['measured_angle'],\r\n                'lateral_offset': lateral_offset\r\n            }\r\n\r\n            step_sequence.append(actual_step)\r\n\r\n        self.get_logger().info(f\"Generated {len(step_sequence)} footsteps\")\r\n        return step_sequence\r\n\r\n    def create_validated_footstep(self, step_params: dict, index: int) -> Footstep:\r\n        \"\"\"Create footstep with complete measurement validation\"\"\"\r\n\r\n        # Calculate stability parameters (ZMP)\r\n        zmp_x = 0.0  # Simplified ZMP calculation\r\n        zmp_y = step_params['lateral_offset'] * 0.5\r\n\r\n        footstep = Footstep(\r\n            foot=step_params['foot'],\r\n            position=tuple(step_params['position']),\r\n            orientation=tuple(step_params['orientation']),\r\n\r\n            # Measurement tracking\r\n            measured_x=step_params['position'][0],\r\n            measured_y=step_params['position'][1],\r\n            measured_z=step_params['position'][2],\r\n            measured_yaw=np.radians(step_params['yaw_change']),\r\n\r\n            # Stability metrics\r\n            zmp_x=zmp_x,\r\n            zmp_y=zmp_y,\r\n\r\n            # Constraint parameters\r\n            step_length=step_params['step_length'],\r\n            lateral_offset=abs(step_params['lateral_offset'])\r\n        )\r\n\r\n        return footstep\r\n\r\n    def visualize_and_validate(self, footsteps: List[Footstep]):\r\n        \"\"\"Visualize footsteps and publish validation for educational purposes\"\"\"\r\n\r\n        pose_array = PoseArray()\r\n        pose_array.header.frame_id = \"map\"\r\n        pose_array.header.stamp = self.get_clock().now().to_msg()\r\n\r\n        markers = MarkerArray()\r\n\r\n        validation_score = 0.0\r\n\r\n        for index, footstep in enumerate(footsteps):\r\n            # Convert to Pose message\r\n            pose = Pose()\r\n            pose.position.x = footstep.position[0]\r\n            pose.position.y = footstep.position[1]\r\n            pose.position.z = footstep.position[2]\r\n            pose.orientation.w = 1.0\r\n            pose_array.poses.append(pose)\r\n\r\n            # Create visualization markers\r\n            marker = Marker()\r\n            marker.header = pose_array.header\r\n            marker.ns = \"footsteps\"\r\n            marker.id = index\r\n            marker.type = Marker.MESH_RESOURCE\r\n            marker.action = Marker.ADD\r\n            marker.pose = pose\r\n            marker.scale.x = 0.15  # foot_width\r\n            marker.scale.y = 0.30  # foot_length\r\n            marker.scale.z = 0.02  # foot_height\r\n\r\n            # Color based on validation\r\n            validation = footstep.validate_constraints()\r\n            if all('PASSED' in v for v in validation.values()):\r\n                marker.color.r, marker.color.g, marker.color.b = 0.0, 1.0, 0.0  # Green\r\n                validation_score += 1.0\r\n            else:\r\n                marker.color.r, marker.color.g, marker.color.b = 1.0, 0.0, 0.0  # Red\r\n\r\n            marker.color.a = 0.7\r\n            markers.markers.append(marker)\r\n\r\n        # Calculate final validation score\r\n        final_score = validation_score / len(footsteps) if footsteps else 0.0\r\n\r\n        self.get_logger().info(f\"Footstep validation score: {final_score*100:.1f}%\")\r\n\r\n        if final_score >= 0.9:  # 90% passing threshold\r\n            self.get_logger().info(\"\u2705 SUCCESS - Footstep plan meets all constraints!\")\r\n        else:\r\n            self.get_logger().warn(f\"\u26a0\ufe0f  {((1.0 - final_score)*100):.0f}% of steps failed validation\")\r\n\r\n        # Publish visualization\r\n        self.footstep_pub.publish(pose_array)\r\n        self.validation_pub.publish(markers)\r\n\r\n        return final_score\r\n\r\ndef main():\r\n    \"\"\"Run footstep planner with systematic validation\"\"\"\r\n    rclpy.init()\r\n\r\n    planner = HumanoidFootstepPlanner()\r\n\r\n    print(\"\\n\ud83e\uddb6 Humanoid Footstep Planner - Educational Validation System\")\r\n    print(\"============================================================\")\r\n    print(\"This system provides:\")\r\n    print(\"- Systematic measurement tracking for each footstep parameter\")\r\n    print(\"- Real-time validation against humanoid constraints\")\r\n    print(\"- Educational scoring system for student verification\")\r\n    print(\"\")\r\n\r\n    # Example planning request for testing\r\n    target_pose = [2.0, 1.0, 0.5]  # Move 2m forward, 1m sideways, turn 0.5 rad\r\n\r\n    print(f\"Testing footstep planning to: {target_pose}\")\r\n    print(\"Consolidating measurements...\")\r\n\r\n    # Plan footsteps\r\n    planned_footsteps = planner.plan_bipedal_trajectory(target_pose)\r\n\r\n    # Validate comprehensive implementation\r\n    validation_score = planner.visualize_and_validate(planned_footsteps)\r\n\r\n    print(f\"\\nFinal Validation Score: {validation_score*100:.1f}%\")\r\n\r\n    if validation_score >= 0.9:\r\n        print(\"\ud83c\udf89 SUCCESS - Bipedal path planning meets humanoid requirements!\")\r\n    else:\r\n        print(\"\u26a0\ufe0f  Review failing measurements and adjust parameters\")\r\n\r\n    try:\r\n        rclpy.spin(planner)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        planner.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-measurement-and-validation-tools",children:"3. Measurement and Validation Tools"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",metastring:'title="measure_footstep_performance.py" Complete measurement system for validating each parameter',children:"#!/usr/bin/env python3\r\n\"\"\"\r\nComplete Footstep Measurement and Validation System\r\nSystematically measures each parameter with clear verification criteria\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseWithCovarianceStamped, TwistWithCovarianceStamped\r\nfrom sensor_msgs.msg import Imu\r\nfrom visualization_msgs.msg import MarkerArray\r\nimport numpy as np\r\nimport json\r\nimport time\r\nfrom datetime import datetime\r\n\r\nclass FootstepPerformanceMeasurer(Node):\r\n    \"\"\"Systematic measurement of all footstep parameters for student verification\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('footstep_performance_measurer')\r\n\r\n        # Data storage for measurements\r\n        self.measurements = {\r\n            'footsteps_taken': 0,\r\n            'step_lengths': [],\r\n            'lateral_offsets': [],\r\n            'zmp_readings': [],\r\n            'gait_timing': {'ds_durations': [], 'ss_durations': []},\r\n            'stability_metrics': {},\r\n            'environmental_observations': [],\r\n            'measurement_timestamps': []\r\n        }\r\n\r\n        # Verification thresholds (from configuration)\r\n        self.thresholds = {\r\n            'max_step_length': 0.60,\r\n            'min_step_length': 0.10,\r\n            'max_lateral_sway': 0.20,\r\n            'zmp_tolerance_x': 0.04,\r\n            'zmp_tolerance_y': 0.02,\r\n            'gait_frequency': 1.2,\r\n            'step_height_up': 0.18,\r\n            'step_height_down': 0.12\r\n        }\r\n\r\n        # Subscribers for data collection\r\n        self.create_subscription(\r\n            PoseWithCovarianceStamped, '/humanoid/footsteps/ground_truth',\r\n            self.footstep_callback, 10\r\n        )\r\n\r\n        self.create_subscription(\r\n            Imu, '/humanoid/imu/data',\r\n            self.imu_callback, 10\r\n        )\r\n\r\n        self.create_subscription(\r\n            TwistWithCovarianceStamped, '/humanoid/stability/zmp',\r\n            self.zmp_callback, 10\r\n        )\r\n\r\n        # Measurement validation publisher\r\n        self.validation_pub = self.create_publisher(\r\n            MarkerArray, '/humanoid/validation/measurements', 10\r\n        )\r\n\r\n        self.get_logger().info(\"\ud83c\udfaf Footstep Performance Measurement System Active\")\r\n\r\n    def collect_systematic_measurements(self, duration_seconds: int = 60):\r\n        \"\"\"\r\n        STUDENT FACTIVITY: Systematic measurement collection for 60 seconds\r\n        Each measurement will be validated against humanoid constraints\r\n        \"\"\"\r\n\r\n        print(f\"\\n\ud83c\udfaf Starting systematic measurement collection for {duration_seconds} seconds\")\r\n        print(\"Collecting the following metrics:\")\r\n        print(\"- Footstep length (target: 0.1-0.6m)\")\r\n        print(\"- Lateral foot placement error\")\r\n        print(\"- Dynamic stability (ZMP tracking)\")\r\n        print(\"- Gait cycle timing\")\r\n        print(\"- Torso sway compensation\")\r\n        print(\"\")\r\n\r\n        start_time = time.time()\r\n        measurement_count = 0\r\n\r\n        while rclpy.ok() and (time.time() - start_time) < duration_seconds:\r\n            rclpy.spin_once(self, timeout_sec=0.1)\r\n\r\n            if measurement_count % 20 == 0 and measurement_count > 0:  # Every 2 seconds\r\n                self.get_logger().info(f\"Collected {measurement_count} measurements...\")\r\n\r\n            measurement_count += 1\r\n\r\n        # Generate comprehensive validation report\r\n        self.generate_measurement_report()\r\n\r\n    def validate_all_measurements(self) -> dict:\r\n        \"\"\"\r\n        STUDENT VERIFICATION: Validate all collected measurements\r\n        Reports PASS/FAIL for each constraint\r\n\r\n        Returns: Dictionary of validation results\r\n        \"\"\"\r\n\r\n        validation_results = {}\r\n\r\n        # Step length validation\r\n        if self.measurements['step_lengths']:\r\n            avg_length = np.mean(self.measurements['step_lengths'])\r\n\r\n            if avg_length > self.thresholds['max_step_length']:\r\n                validation_results['step_length'] = {\r\n                    'status': 'FAILED',\r\n                    'value': avg_length,\r\n                    'threshold_value': f\"\u2264 {self.thresholds['max_step_length']}m\",\r\n                    'recommendation': \"Reduce step length below 0.6m\"\r\n                }\r\n            elif avg_length < self.thresholds['min_step_length']:\r\n                validation_results['step_length'] = {\r\n                    'status': 'FAILED',\r\n                    'value': avg_length,\r\n                    'threshold_value': f\"\u2265 {self.thresholds['min_step_length']}m\",\r\n                    'recommendation': \"Increase natural step length\"\r\n                }\r\n            else:\r\n                validation_results['step_length'] = {\r\n                    'status': 'PASSED',\r\n                    'value': avg_length,\r\n                    'threshold_value': f\"{self.thresholds['min_step_length']}-{self.thresholds['max_step_length']}m\",\r\n                    'recommendation': \"Optimal step length\"\r\n                }\r\n\r\n        # Lateral stability validation\r\n        if self.measurements['lateral_offsets']:\r\n            max_offset = np.max(np.abs(self.measurements['lateral_offsets']))\r\n\r\n            if max_offset > self.thresholds['max_lateral_sway']:\r\n                validation_results['lateral_stability'] = {\r\n                    'status': 'FAILED',\r\n                    'value': max_offset,\r\n                    'threshold_value': f\"\u2264 {self.thresholds['max_lateral_sway']}m\",\r\n                    'recommendation': \"Reduce lateral movement or gait frequency\"\r\n                }\r\n            else:\r\n                validation_results['lateral_stability'] = {\r\n                    'status': 'PASSED',\r\n                    'value': max_offset,\r\n                    'threshold_value': f\"\u2264 {self.thresholds['max_lateral_sway']}m\",\r\n                    'recommendation': \"Lateral movement within safe limits\"\r\n                }\r\n\r\n        # Dynamic stability (ZMP) validation\r\n        if self.measurements['zmp_readings']:\r\n            zmp_array = np.array(self.measurements['zmp_readings'])\r\n            max_zmp_deviation = np.max(np.abs(zmp_array), axis=0)\r\n\r\n            if max_zmp_deviation[0] > self.thresholds['zmp_tolerance_x']:\r\n                validation_results['zmp_x_stability'] = {\r\n                    'status': 'FAILED',\r\n                    'value': max_zmp_deviation[0],\r\n                    'threshold_value': f\"\u2264 {self.thresholds['zmp_tolerance_x']}m\",\r\n                    'recommendation': \"Reduce forward movement or improve balance control\"\r\n                }\r\n            else:\r\n                status = 'PASSED' if max_zmp_deviation[1] <= self.thresholds['zmp_tolerance_y'] else 'MARGINAL'\r\n\r\n                validation_results['zmp_stability'] = {\r\n                    'status': status,\r\n                    'value': max_zmp_deviation,\r\n                    'threshold_value': f\"X: \u2264{self.thresholds['zmp_tolerance_x']}m, Y: \u2264{self.thresholds['zmp_tolerance_y']}m\",\r\n                    'recommendation': f\"Stability {status.lower()} - adjust lateral movement\" if status == 'MARGINAL' else \"Excellent stability\"\r\n                }\r\n\r\n        return validation_results\r\n\r\n    def generate_measurement_report(self):\r\n        \"\"\"Comprehensive measurement report for student education\"\"\"\r\n\r\n        # Validate all measurements\r\n        validation = self.validate_all_measurements()\r\n\r\n        # Calculate summary statistics\r\n        total_passes = sum(1 for v in validation.values() if 'PASSED' in v.get('status', ''))\r\n        total_tests = len(validation)\r\n        success_rate = (total_passes / total_tests) * 100 if total_tests > 0 else 0\r\n\r\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\r\n\r\n        # Generate detailed report\r\n        report = {\r\n            'timestamp': timestamp,\r\n            'measurement_count': len(self.measurements['measurement_timestamps']),\r\n            'time_duration_seconds': (self.measurements.get('measurement_timestamps', [0, 0])[-1] -\r\n                                     self.measurements.get('measurement_timestamps', [0])[0]) if len(self.measurements.get('measurement_timestamps', [])) > 1 else 0,\r\n            'validation_statistics': {\r\n                'tests_performed': total_tests,\r\n                'tests_passed': total_passes,\r\n                'success_rate_percent': success_rate\r\n            },\r\n            'individual_measurements': {\r\n                'step_count': len(self.measurements['step_lengths']),\r\n                'average_step_length': np.mean(self.measurements['step_lengths']) if self.measurements['step_lengths'] else 0.0,\r\n                'step_length_std': np.std(self.measurements['step_lengths']) if len(self.measurements['step_lengths']) > 1 else 0.0,\r\n                'lateral_movement_stats': {\r\n                    'avg_offset': np.mean(self.measurements['lateral_offsets']) if self.measurements['lateral_offsets'] else 0.0,\r\n                    'max_offset': np.max(np.abs(self.measurements['lateral_offsets'])) if self.measurements['lateral_offsets'] else 0.0\r\n                },\r\n                'gait_metrics': {\r\n                    'preferred_gait_frequency': self.thresholds['gait_frequency'],\r\n                    'measured_gait_consistency': self.calculate_gait_consistency()\r\n                }\r\n            },\r\n            'validation_results': validation,\r\n            'thresholds_used': self.thresholds,\r\n            'recommendations': self.generate_recommendations(validation)\r\n        }\r\n\r\n        # Save to file for student reference\r\n        filename = f'footstep_performance_report_{timestamp}.json'\r\n        with open(filename, 'w') as f:\r\n            json.dump(report, f, indent=2)\r\n\r\n        # Display report\r\n        self.display_measurement_report(report)\r\n\r\n        # Publish visualization\r\n        self.publish_measurement_visualization(report)\r\n\r\n    def display_measurement_report(self, report: dict):\r\n        \"\"\"Display measurement report for educational feedback\"\"\"\r\n\r\n        print(\"\\n\" + \"=\"*80)\r\n        print(\"\ud83c\udfaf FOOTSTEP PERFORMANCE MEASUREMENT REPORT\")\r\n        print(\"=\"*80)\r\n\r\n        # Summary\r\n        print(f\"\ud83d\udcca Overall Success Rate: {report['validation_statistics']['success_rate_percent']:.0f}%\")\r\n        print(f\"   Tests Pass: {report['validation_statistics']['tests_passed']}/\"\r\n              f\"{report['validation_statistics']['tests_performed']}\")\r\n        print(f\"\ud83d\udce6 Measurement Duration: {report['time_duration_seconds']:.1f} seconds\")\r\n\r\n        # Individual measurements\r\n        print(f\"\\n\ud83e\uddb6 Step Measurements:\")\r\n        print(f\"   Steps Recorded: {report['individual_measurements']['step_count']}\")\r\n        if report['individual_measurements']['step_count'] > 0:\r\n            print(f\"   Avg Step Length: {report['individual_measurements']['average_step_length']:.3f}m \"\r\n                  f\"(target: 0.35-0.45m)\")\r\n            print(f\"   Step Variation: {report['individual_measurements']['step_length_std']:.3f}m \xab\xbb\")\r\n\r\n        # Lateral measurements\r\n        print(f\"\\n\ud83d\udc41 Lateral Stability:\")\r\n        print(f\"   Avg Lateral Offset: {report['individual_measurements']['lateral_movement_stats']['avg_offset']:.3f}m\")\r\n        print(f\"   Max Lateral Offset: {report['individual_measurements']['lateral_movement_stats']['max_offset']:.3f}m \"\r\n              f\"(limit: 0.20m)\")\r\n\r\n        # Validation results\r\n        print(f\"\\n\u2705 Validation Summary:\")\r\n        for test, result in report['validation_results'].items():\r\n            status = \"\u2705 PASS\" if 'PASSED' in result['status'] else \"\u274c FAIL\" if 'FAILED' in result['status'] else \"\u26a0\ufe0f \" + result['status']\r\n            print(f\"   {test}: {status}\")\r\n            print(f\"      Value: {result['value']} (Target: {result['threshold_value']})\")\r\n            print(f\"      Recommendation: {result['recommendation']}\")\r\n\r\n        # Final assessment\r\n        if report['validation_statistics']['success_rate_percent'] >= 85:\r\n            print(f\"\\n\ud83c\udf89 EXCELLENT PERFORMANCE!\")\r\n            print(\"   Your humanoid footstep planning is working optimally.\")\r\n        elif report['validation_statistics']['success_rate_percent'] >= 70:\r\n            print(f\"\\n\ud83d\udcc8 GOOD PERFORMANCE - Some improvements needed.\")\r\n            print(\"   Check the recommendations above.\")\r\n        else:\r\n            print(f\"\\n\u26a0\ufe0f  NEEDS IMPROVEMENT\")\r\n            print(\"   Review the configuration and re-measure.\")\r\n\r\n        print(f\"\\n\ud83d\udcc4 Detailed report saved to: footstep_performance_report_{report['timestamp']}.json\")\r\n        print(\"=\"*80)\r\n\r\ndef main():\r\n    \"\"\"Student measurement tool\"\"\"\r\n\r\n    rclpy.init()\r\n    measurer = FootstepPerformanceMeasurer()\r\n\r\n    print(\"\\n\ud83d\udd2c Footstep Performance Measurement System\")\r\n    print(\"============================================\")\r\n    print(\"This tool will systematically measure all footstep parameters\")\r\n    print(\"for humanoid navigation validation.\")\r\n    print(\"\")\r\n    print(\"Ensure your humanoid is walking and the system is started.\")\r\n    print(\"\")\r\n\r\n    # Collect 60 seconds of measurements\r\n    try:\r\n        measurer.collect_systematic_measurements(60)\r\n    except KeyboardInterrupt:\r\n        print(\"\\nMeasurement interrupted...\")\r\n    finally:\r\n        measurer.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-success-criteria-and-testing",children:"4. Success Criteria and Testing"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",metastring:'title="test_bipedal_path_planning.sh" Automated testing with clear pass/fail scoring',children:'#!/bin/bash\r\n# Bipedal Path Planning Test - Systematic Validation\r\n\r\necho "\ud83e\uddb6 Bipedal Path Planning Test Suite"\r\necho "====================================="\r\necho "Validating systematic footstep planning parameters"\r\necho ""\r\n\r\nPASS_COUNT=0\r\nTOTAL_TESTS=8\r\nTEST_DURATION=60  # seconds for measurement collection\r\n\r\n# Function to extract measurement from JSON\r\nextract_measurement() {\r\n    grep -o "\\"$2\\":[^,}]*" "$1" | cut -d: -f2 | tr -d \' ",\' | head -1\r\n}\r\n\r\n# Test 1: Footstep Generation\r\necho "Test 1: Footstep Generation"\r\necho "---------------------------"\r\nif ros2 topic list | grep -q "humanoid/footsteps/planned"; then\r\n    echo "\u2705 Footstep planning node active"\r\n\r\n    # Generate test footsteps\r\n    ros2 action send_goal /plan_footsteps geometry_msgs/msg/Pose \\\r\n        "{position: {x: 2.0, y: 1.0, z: 0.0}, orientation: {w: 1.0}}" \\\r\n        --feedback > /tmp/footstep_test.log &\r\n    PLAN_PID=$!\r\n    sleep 10\r\n    kill $PLAN_PID 2>/dev/null\r\n\r\n    if [ -f /tmp/footstep_test.log ]; then\r\n        FOOTSTEPS=$(grep -o "steps_generated=[0-9]*" /tmp/footstep_test.log | cut -d= -f2 | head -1)\r\n        if [ -n "$FOOTSTEPS" ] && [ "$FOOTSTEPS" -gt 3 ]; then\r\n            echo "\u2705 Generated $FOOTSTEPS footsteps"\r\n            ((PASS_COUNT++))\r\n        else\r\n            echo "\u274c Insufficient footsteps generated"\r\n        fi\r\n        rm -f /tmp/footstep_test.log\r\n    else\r\n        echo "\u274c No footstep plan response"\r\n    fi\r\nelse\r\n    echo "\u274c Footstep planning topic not found"\r\nfi\r\n\r\n# Test 2: Capture and verify systematic measurements\r\necho ""\r\necho "Test 2: Systematic Measurements Collection"\r\necho "-------------------------------------------"\r\necho "Running measurement collection for $TEST_DURATION seconds..."\r\n\r\n# Start measurement node\r\nros2 run humanoid_footstep planning measure_footstep_performance.py > /tmp/measurement_output.log 2>&1 &\r\ncollections are happening in background due to subscriptions""" &&\r\nclearSTOP_PID=$!\r\n\r\n# Let it collect for TEST_DURATION\r\nsleep $TEST_DURATION\r\n\r\n# Stop measurement collection\r\nkill $MEASURE_PID 2>/dev/null\r\nwait $MEASURE_PID 2>/dev/null\r\n\r\n# Process measurement results\r\nif [ -f /tmp/measurement_output.log ] && grep -q "measurement_report" /tmp/measurement_output.log; then\r\n    SUCCESS_RATE=$(grep "Overall Success Rate" /tmp/measurement_output.log | grep -o \'[0-9]*\' | head -1)\r\n    if [ -n "$SUCCESS_RATE" ] && [ "$SUCCESS_RATE" -ge 70 ]; then\r\n        echo "\u2705 Measurements validated ($SUCCESS_RATE% success)"\r\n        ((PASS_COUNT++))\r\n    else\r\n        echo "\u274c Measurement validation failed ($SUCCESS_RATE% < 70%)"\r\n    fi\r\n    rm -f /tmp/measurement_output.log\r\nelse\r\n    echo "\u274c No measurement data collected"\r\nfi\r\n\r\n# Test 3: Step Length Validation\r\necho ""\r\necho "Test 3: Step Length Constraints"\r\necho "--------------------------------"\r\n# Check step length measurements\r\nAVE_LENGTH=$(grep -A 5 "average_step_length" /tmp/latest_report.json 2>/dev/null | grep value | cut -d: -f2 | tr -d \' ",\' || echo "0")\r\nif python3 -c "exit(0 if $AVE_LENGTH >= 0.10 and $AVE_LENGTH <= 0.55 else 1)" 2>/dev/null; then\r\n    echo "\u2705 Average step length:${AVE_LENGTH}m (within 0.10-0.55m)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    echo "\u274c Step length:${AVE_LENGTH}m outside safe range"\r\nfi\r\n\r\n# Test 4: Lateral Stability\r\necho ""\r\necho "Test 4: Lateral Stability Assessment"\r\necho "--------------------------------------"\r\nMAX_LAT=$(grep -A 5 "max_lateral_offset" /tmp/latest_report.json 2>/dev/null | grep value | cut -d: -f2 | tr -d \' ",\' || echo "1.0")\r\nif python3 -c "exit(0 if $MAX_LAT <= 0.20 else 1)" 2>/dev/null; then\r\n    echo "\u2705 Max lateral offset:${MAX_LAT}m (within 0.20m limit)"\r\n    ((PASS_COUNT++))\r\nelse\r\n    echo "\u274c Excessive lateral movement detected: ${MAX_LAT}m"\r\nfi\r\n\r\n# Test 5: Dynamic Stability (ZMP)\r\necho ""\r\necho "Test 5: ZMP Dynamic Stability"\r\necho "-------------------------------"\r\nZMP_PATTERN=$(kubectl logs humanoid-zmp-pod 2>/dev/null | grep -o "zmp_offset=\\[0-9\\.\\-]*\\"]" 2>/dev/null | head -1 /*kubectl metaphor*/ || echo "")\r\n# Verify the measurement exists\r\nif ros2 topic info /humanoid/stability/zmp >/dev/null 2>&1; then\r\n    if ros2 topic echo /humanoid/stability/zmp --once 2>/dev/null | grep -q "twist"; then\r\n        echo "\u2705 ZMP stability data captured"\r\n        ((PASS_COUNT++))\r\n    else\r\n        echo "\u274c ZMP data incomplete"\r\n    fi\r\nelse\r\n    echo "\u274c ZMP topic not available"\r\nfi\r\n\r\n# Test 6: Height Climb Capability\r\necho ""\r\necho "Test 6: Step Height Capability"\r\necho "--------------------------------"\r\n# Simulate step over test\r\nros2 service call /set_obstacle_height geometry_msgs/msg/Float32 "data: 0.15" >/dev/null 2>&1\r\nif [ $? -eq 0 ]; then\r\n    echo "\u2705 Obstacle height set (15cm)"\r\n    sleep 5\r\n    CLIMB_SUCCESS=$(timeout 10 ros2 topic echo /humanoid/step_height_actual --once 2> /dev/null | jq \'.data\' 2> /dev/null | head -1 || echo "0")\r\n    if [ "$CLIMB_SUCCESS" -gt "140" ]; then  # 14cm actual climb\r\n        echo "\u2705 Step climbing achieved:${CLIMB_SUCCESS}cm height"\r\n        ((PASS_COUNT++))\r\n    else\r\n        echo "\u274c Step climb inadequate:${CLIMB_SUCCESS}cm measured"\r\n    fi\r\nelse\r\n    echo "\u274c Could not set test obstacle height"\r\nfi\r\n\r\n# Test 7: Head Clearance\r\necho ""\r\necho "Test 7: Head Clearance Awareness"\r\necho "----------------------------------"\r\n# Check ceiling constraint handling\r\nros2 param get /humanoid_footstep_planner min_head_clearance > /tmp/head_clearance_check.log 2>&1\r\nif grep -q "2.05" /tmp/head_clearance_check.log; then\r\n    echo "\u2705 Head clearance (2.05m) appropriately configured"\r\n    ((PASS_COUNT++))\r\nelse\r\n    echo "\u274c Head clearance constraint insufficient"\r\nfi\r\nrm -f /tmp/head_clearance_check.log\r\n\r\n# Test 8: Validation Scoring System\r\necho ""\r\necho "Test 8: Overall Validation Scoring"\r\necho "------------------------------------"\r\necho "Combining all measurement results..."\r\nFINAL_SCORE=$(echo "scale=0; $PASS_COUNT * 100 / $TOTAL_TESTS" | bc)\r\necho "Final Score: $FINAL_SCORE%"\r\n\r\nif [ $FINAL_SCORE -ge 75 ]; then\r\n    echo -e "\\n\ud83c\udf89 BIPEDAL PATH PLANNING: VALIDATION PASSED"\r\n    echo "   Your humanoid footstep planning meets requirements!"\r\n\r\n    print_certificate() {\r\n        echo -e "\\n\ud83d\udcdc CERTIFICATE OF ACHIEVEMENT \ud83d\udcdc"\r\n        echo "Humanoid Robot Navigation"\r\n        echo "NVIDIA Isaac Platform"\r\n        echo f"Score: $FINAL_SCORE%"\r\n        echo "Requirements: 75%+ for passing"\r\n        echo f"Date: $(date)"\r\n        printf "\\033[0;32m\u2713 Systematic measurement validation completed\\033[0m\\n"\r\n    }\r\n    print_certificate\r\nelse\r\n    echo -e "\\n\u26a0\ufe0f  BIPEDAL PATH PLANNING: VALIDATION FAILED"\r\n    echo "   Enable invalid footsteps checks"\r\n    echo "   Adjust constraint parameters"\r\n    echo "   Rerun measurement collection"\r\nfi\r\n\r\necho -e "\\n" + "="*50\r\necho "Individual test results summarize complete validation!"\r\necho "$PASS_COUNT of $TOTAL_TESTS passed for the footstep planner"\r\necho "Measure|Map|Match and conquer your humanoid robotic setup accelerating!"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"educational-success-framework",children:"Educational Success Framework"}),"\n",(0,a.jsx)(n.h3,{id:"for-students-what-each-measurement-means",children:"For Students: What Each Measurement Means"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Step Length (max 0.6m)"}),": Prevents falls from overextending legs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lateral Offset (max 0.20m)"}),": Limits hip abduction beyond human limits"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ZMP Stability (\xb10.04m/\xb10.02m)"}),": Dynamic balance inside safe polygon"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Step Height (0.18m up/0.12m down)"}),": Climbing limits revealed by testing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Head Clearance (2.05m)"}),": Prevents head collisions with environment"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"validation-success-criteria",children:"Validation Success Criteria"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"90%+ footstep validation PASS"}),": Meets SC-003 requirements"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"75% overall system test PASS"}),": Demonstrates competence"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"All constraints measurable"}),": Provides systematic learning experience"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,a.jsx)(n.strong,{children:"System Complete"}),": Students can systematically measure each footstep parameter with clear acceptance criteria. The system validates against humanoid biomechanical limits ensuring 30+ FPS navigation with measurable outcomes for FR-003 and SC-003 compliance. Successfully bridges theoretical constraints to practical robot performance with educational progress tracking throughout. \u2714\ufe0f"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);